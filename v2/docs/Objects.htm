<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>对象 - 定义 &amp; 使用 | AutoHotkey v2</title>
<meta name="description" content="Learn details about basic usage of objects, extended usage of objects, custom objects, default base object and implementation of objects." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>对象</h1>

<p class="warning"><strong>注意:</strong> 该页面正在开发进程中.</p>

<p><i>对象</i> 组合了许多 <em>属性</em> 和 <a href="Concepts.htm#methods"><em>方法</em></a>:</p>
<p>相关话题:</p>
<ul>
  <li><a href="Concepts.htm#objects">对象</a>: 对象的一般解释.</li>
  <li><a href="Concepts.htm#object-protocol">对象协议</a>: 关于脚本如何与对象交互的细节.</li>
  <li><a href="objects/Functor.htm">函数对象</a>: 可以被 <em>调用</em> 的对象.</li>
</ul>

<p><b>IsObject</b> 可以用来确定一个值是否为对象:</p>
<pre>Result := IsObject(<i>expression</i>)</pre>

<p>有关标准对象类型的列表, 请参阅文档侧栏中的 <em>对象类型</em>. 这包括两种基本类型:</p>
<ul>
  <li><strong>AutoHotkey 对象</strong> 是<a href="objects/Object.htm">对象</a>类的实例. 它们支持 ad hoc 属性和方法, 并具有发现哪些属性和方法存在的方法. 从对象中派生了<a href="objects/Array.htm">数组(线性数组)</a>, <a href="objects/Map.htm">映射(关联数组)</a> 和所有用户自定义的和内置的类.</li>
  <li><strong>COM 对象</strong> 如由 <a href="commands/ComObjCreate.htm">ComObjCreate</a> 创建的那些对象. 这些是由外部库实现的, 因此通常与 AutoHotkey 对象的行为不同. ComObject 通常表示实现 <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch 接口</a>的 COM 或 "Automation" 对象, 但也用于<a href="commands/ComObject.htm">包装特定类型的值</a>以传递给 COM 对象和函数.</li>
</ul>

<h2>目录</h2>
<ul>
  <li><a href="#Usage">基本用法</a> - <a href="#Usage_Simple_Arrays">数组</a>, <a href="#Usage_Associative_Arrays">映射(关联数组)</a>, <a href="#Usage_Objects">对象</a>, <a href="#Usage_Freeing_Objects">释放对象</a></li>
  <li><a href="#Extended_Usage">扩展用法</a> - <a href="#Function_References">函数引用</a>, <a href="#Usage_Arrays_of_Arrays">数组嵌套</a></li>
  <li><a href="#Custom_Objects">自定义对象</a> - <a href="#creating-a-base-object">Creating a Base Object</a>, <a href="#Custom_Classes">类</a>, <a href="#Custom_NewDelete">创建和销毁</a>, <a href="#Meta_Functions">元函数</a></li>
  <li><a href="#Default_Base_Object">默认基对象</a> - <a href="#Automatic_Var_Init">自动初始化变量</a>, <a href="#Pseudo_Properties">伪属性</a>, <a href="#Default__Warn">调试</a></li>
  <li><a href="#Implementation">实现</a> - <a href="#Reference_Counting">引用计数</a>, <a href="#Implementation_Pointers">对象的指针</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">基本用法</h2>

<h3 id="Usage_Simple_Arrays">数组</h3>
<p>创建<a href="objects/Array.htm">数组</a>:</p>
<pre>MyArray := [Item1, Item2, ..., ItemN]
MyArray := Array(Item1, Item2, ..., ItemN)</pre>
<p>检索项目(或 <em>数组元素</em>):</p>
<pre>Value := MyArray[Index]</pre>
<p>更改项目的值(必须已经存在于数组中):</p>
<pre>MyArray[Index] := Value</pre>
<p>使用 <a href="objects/Object.htm#InsertAt">InsertAt</a> 方法在指定索引处插入一个或多个项目:</p>
<pre>MyArray.<a href="objects/Object.htm#InsertAt">InsertAt</a>(Index, Value, Value2, ...)</pre>
<p>使用 <a href="objects/Object.htm#Push">Push</a> 方法追加一个或多个项目:</p>
<pre>MyArray.<a href="objects/Object.htm#Push">Push</a>(Value, Value2, ...)</pre>
<p>使用 <a href="objects/Object.htm#RemoveAt">RemoveAt</a> 方法移除项目:</p>
<pre>RemovedValue := MyArray.<a href="objects/Object.htm#RemoveAt">RemoveAt</a>(Index)</pre>
<p>使用 <a href="objects/Object.htm#Pop">Pop</a> 移除最后一项:</p>
<pre>RemovedValue := MyArray.<a href="objects/Object.htm#Pop">Pop</a>()</pre>
<p><a href="objects/Array.htm#Length">Length</a> 返回数组中的项目数. 通过索引或 For-循环可以遍历数组的内容. 例如:</p>
<pre>MyArray := ["one", "two", "three"]

<em>; 从 1 依次递加到数组的项目数:</em>
Loop MyArray.Length
    MsgBox MyArray[A_Index]

<em>; 枚举数组内容:</em>
For index, value in MyArray
    MsgBox "Item " index " is '" value "'"

<em>; Same thing again:</em>
For value in MyArray
    MsgBox "Item " A_Index " is '" value "'"
</pre>

<h3 id="Usage_Associative_Arrays">映射(关联数组)</h3>
<p><a href="objects/Map.htm">Map</a> 或关联数组是包含一组键(每个键是唯一的) 和一组值的对象, 其中每个键和一个值关联. 键可以为字符串, 整数或对象, 而值可以为任何类型. 关联数组可以用如下方法创建:</p>
<pre>MyMap := Map("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>检索一个项目, 其中 <code>键</code> 可以是<a href="Concepts.htm#variables">变量</a>或<a href="Language.htm#expressions">表达式</a>:</p>
<pre>Value := MyMap[Key]</pre>
<p>赋值项目:</p>
<pre>MyMap[Key] := Value</pre>
<p>使用 <a href="objects/Object.htm#Delete">Delete</a> 方法移除项目:</p>
<pre>RemovedValue := MyMap.Delete(Key)</pre>
<p>枚举项目:</p>
<pre>MyMap := Map("ten", 10, "twenty", 20, "thirty", 30)
<a href="commands/For.htm">For</a> key, value in MyMap
    MsgBox key ' = ' value</pre>
<p>关联数组可以是稀疏分布的 - 即 <code>{1:"a",1000:"b"}</code> 仅包含两个键值对, 而不是 1000 个.</p>

<h3 id="Usage_Objects">对象</h3>
<p>对象可以有 <em>属性</em>, <em>方法</em> 和 <em>项目</em>(如 数组元素). 项目可以使用 <code>[]</code> 来访问, 如前面几节所示. 属性和方法通常通过在一个点后面加上一个标识符(只是一个<a href="Concepts.htm#names">名称</a>) 来访问.</p>
<p><strong>示例:</strong></p>
<p>检索或设置一个原义名称为 <em>Property</em> 的属性:</p>
<pre>Value := Object.Property</pre>
<pre>Object.Property := Value</pre>
<p>检索或设置通过计算<a href="Language.htm#expressions">表达式</a>或<a href="Concepts.htm#variables">变量</a>来确定名称的属性:</p>
<pre>Value := Object.%Expression%</pre>
<pre>Object.%Expression% := Value</pre>
<p>调用一个原义名称为 <em>Method</em> 的方法:</p>
<pre>ReturnValue := Object.Method(Parameters)</pre>
<p>调用通过计算表达式或变量来确定名称的方法:</p>
<pre>ReturnValue := Object.%Expression%(Parameters)</pre>
<p>有些属性可以接受参数:</p>
<pre>Value := Object.Property[Parameters]
Object.Property[Parameters] := Value</pre>
<p>In fact, the array indexing syntax <code>MyArray[Index]</code> actually invokes the <code>__Item</code> property of <code>MyArray</code>, passing <code>Index</code> as a parameter.</p>

<h3 id="Usage_Freeing_Objects">释放对象</h3>
<p>脚本不会显式的释放对象. 当到对象的最后一个引用被释放时, 会自动释放这个对象. 当某个保存引用的变量被赋为其他值时, 会自动释放它原来保存的引用. 例如:</p>
<pre>obj := {}  <em>; 创建对象.</em>
obj := ""  <em>; 释放最后一个引用, 因此释放对象.</em></pre>
<p>类似地, 当属性或数组元素被赋为其他值或从对象中删除时, 存储在属性或数组元素中的引用将被释放.</p>
<pre>arr := [{}]  <em>; 创建包含对象的数组.</em>
arr[1] := {}  <em>; 再创建一个对象, 隐式释放第一个对象.</em>
arr.RemoveAt(1)  <em>; 移除并释放第二个对象.</em></pre>
<p id="Circular_References">由于在释放一个对象时, 到这个对象的所有引用都必须被释放, 所以包含循环引用的对象无法被自动释放. 例如, 如果 <code>x.child</code> 引用 <code>y</code> 且 <code>y.parent</code> 引用了 <code>x</code>, 则清除 <code>x</code> 和 <code>y</code> 是不够的, 因为父对象仍然包含到这个子对象的引用, 反之亦然. 要避免此问题, 请首先移除循环引用.</p>
<pre>
x := {}, y := {}             <em>; 创建两个对象.</em>
x.child := y, y.parent := x  <em>; 创建循环引用.</em>

y.parent := ""               <em>; 在释放对象前必须移除循环引用.</em>
x := "", y := ""             <em>; 如果没有上一行, 则此行无法释放对象.</em>
</pre>
<p>想了解更多高级用法和细节, 请参阅 <a href="#Reference_Counting">引用计数</a>.</p>

<h2 id="Extended_Usage">扩展用法</h2>
<h3 id="Function_References">函数引用</h3>
<p>如果变量 <i>func</i> 包含一个函数名, 此函数可以通过表达式 <code><a href="Functions.htm#DynCall">%func%()</a></code> 调用.  然而, 由于每次都需要解析函数名, 所以多次调用时效率低下. 为了改善性能, 脚本可以获取到函数的引用并保存以供后面使用:</p>
<pre>MyFuncRef := Func("MyFunc")</pre>
<p>可使用如下语法通过引用来调用函数:</p>
<pre>
RetVal := <a href="Functions.htm#DynCall">%MyFuncRef%</a>(<i>Params</i>)
RetVal := MyFuncRef.<a href="objects/Func.htm#Call">Call</a>(<i>Params</i>)
</pre>
<p>有关函数引用的其他属性的详细信息, 请参阅 <a href="objects/Func.htm">Func 对象</a>.</p>
<p>In most cases, any <a href="objects/Functor.htm">callable object</a> can be used in place of a function reference.</p>

<h3 id="Usage_Arrays_of_Arrays">数组嵌套</h3>
<p>Although "multi-dimensional" arrays are not supported, a script can combine multiple arrays or maps. For example:</p>
<pre>
grid := [[1,2,3],
         [4,5,6],
         [7,8,9]]
MsgBox grid[1][3] <em>; 3</em>
MsgBox grid[3][2] <em>; 8</em>
</pre>
<p>A custom object can implement multi-dimensional support by defining an __Item property. For example:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Length := x * y
        this.Width := x
        this.Height := y
    }
    __Item[x, y] {
        get => base[this.Width * (y-1) + x]
        set => base[this.Width * (y-1) + x] := value
    }
}

grid := Array2D.new(3, 4)
grid[1, 4] := "#"
grid[2, 3] := "#"
grid[2, 2] := "#"
grid[3, 1] := "#"
gridtext := ""
Loop grid.Width {
    x := A_Index
    Loop grid.Height {
        y := A_Index
        gridtext .= grid[x, y] || "-"
    }
    gridtext .= "`n"
}
MsgBox gridtext
</pre>
<p>A real script should perform error-checking and override other methods, such as __Enum to support enumeration.</p>

<h2 id="Custom_Objects">自定义对象</h2>
<p>There are two general ways to create custom objects:</p>
<ul>
  <li><em>Ad hoc</em>: create an object and add properties and methods.</li>
  <li><em>Delegation</em>: define properties and methods in a shared <em>base object</em> or class.</li>
</ul>
<p><a href="#Meta_Functions">Meta-functions</a> can be used to further control how an object behaves.</p>
<p class="note"><strong>Note:</strong> Within this section, an <em>object</em> is any instance of the <a href="objects/Object.htm">Object</a> class. This section does not apply to COM objects.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Properties and methods can generally be added to new objects at any time. For example, an object with one property and one method might be constructed like this:</p>
<pre><em>; 创建对象.</em>
thing := {}
<em>; 存储值.</em>
thing.foo := "bar"
<em>; Define a method.</em>
thing.DefineMethod "test", Func("thing_test")
<em>; 调用方法.</em>
thing.test()

thing_test(this) {
   MsgBox this.foo
}</pre>
<p>调用 <code>thing.test()</code> 时, <i>thing</i> 会自动被插入到参数列表的开始处. 按照约定, 函数是通过结合对象的 "类型" 和方法名来命名的, but this is not a requirement.</p>
<p>See also: <a href="objects/Object.htm#DefineMethod">DefineMethod</a>, <a href="objects/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objects are <em>prototype-based</em>. That is, any properties or methods not defined in the object itself can instead be defined in the object's <a href="objects/Object.htm#Base">base</a>. This is known as <em>inheritance by delegation</em> or <em>differential inheritance</em>, because an object can implement only the parts that make it different, while delegating the rest to its base.</p>
<p>Although a base object is also generally known as a prototype, we use "a class's <a href="objects/Class.htm#Prototype">Prototype</a>" to mean the object upon which every instance of the class is based, and "base" to mean the object upon which an instance is based (or sometimes the <a href="#Custom_Classes_base">base class/superclass</a> of the current class).</p>
<p class="note">AutoHotkey's object design was influenced primarily by JavaScript and Lua, with a little C#. We use <code><i>obj</i>.base</code> in place of JavaScript's <code><i>obj</i>.__proto__</code> and <code><i>cls</i>.Prototype</code> in place of JavaScript's <code><i>func</i>.prototype</code>. (Class objects are used in place of constructor functions.)</p>

 <p>An object's base is also used to identify its type or class. For example, <code>x := []</code> creates an object <em>based on</em> <code>Array.Prototype</code>, which means that the expressions <code>x is Array</code> and <code>x.HasBase(Array.Prototype)</code> are true, and <code>type(x)</code> returns "Array".</p>
<p>Any instance of Object or a derived class can be a base object, but an object can only be <a href="objects/Object.htm#Base">assigned as the base</a> of an object with the same native type. This is to ensure that built-in methods can always identify the native type of an object, and operate only on objects that have the correct binary structure.</p>
<p>Base objects can be defined two different ways:</p>
<ul>
  <li>By <a href="#creating-a-base-object">creating a normal object</a>.</li>
  <li>By <a href="#Custom_Classes">defining a class</a>. Each class has a <a href="objects/Class.htm#Prototype">Prototype</a> property containing an object which all instances of that class are based on, while the class itself becomes the base object of any direct subclasses.</li>
</ul>
<p>A base object can be assigned to the <a href="objects/Object.htm#Base">base</a> property of another object, but typically an object's base is set implicitly when it is created.</p>

 <h3 id="creating-a-base-object">Creating a Base Object</h3>
<p>Any object can be used as the base of any other object which has the same native type. The following example builds on the previous example under <a href="#ad-hoc">Ad Hoc</a> (combine the two before running it):</p>
<pre>other := {}
other.base := thing
other.test()</pre>
<p>此时, <i>other</i> 从 <i>thing</i> 继承了 <i>foo</i> 和 <i>test</i>. 这种继承是动态的, 所以如果 <code>thing.foo</code> 被改变了, 这改变也会由 <code>other.foo</code> 表现出来. 如果脚本赋值给 <code>other.foo</code>, 值存储到 <i>other</i> 中并且之后对 <code>thing.foo</code> 任何改变都不会影响 <code>other.foo</code>. 当调用 <code>other.test()</code> 时, 它的 <i>this</i> 参数包含 <i>other</i> 而不是 <i>thing</i> 的引用.
</p>

<h3 id="Custom_Classes">类</h3>
<blockquote>In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).
<a href="https://en.wikipedia.org/wiki/Class_(computer_programming)" class="source">Wikipedia</a></blockquote>
<p>从根本上讲, <em>类</em> 是具有某些共同属性或属性的一组或一类事物. 在 AutoHotkey 中, <code>class</code> 定义了属性和方法共享的类的实例. 一个 <em>实例</em> 只是一个继承了类的属性和方法的对象, 并且通常也可以被标识为属于该类(例如使用表达式 <code><i>instance</i> is <i>ClassName</i></code>). 实例通常通过调用 <a href="objects/Class.htm#New"><em>ClassName</em>.new()</a> 创建.</p>
<p>Since <a href="objects/Object.htm">Objects</a> are <a href="#ad-hoc">dynamic</a> and <a href="#delegation">prototype-based</a>, each class consists of two parts:</p>
<ul>
  <li>The class has a <a href="objects/Class.htm#Prototype">Prototype</a> object, on which all instances of the class are based. All methods and properties that apply to a specific instance are contained by the prototype object. This includes all properties and methods which lack the <code>static</code> keyword.</li>
  <li>The class itself is an object, containing only static methods and properties. This includes all properties and methods with the <code>static</code> keyword, and all nested classes. These do not apply to a specific instance, and can be used by referring to the class itself by name.</li>
</ul>
<p>The following shows most of the elements of a class definition:</p>
<pre>class ClassName extends BaseClassName
{
    InstanceVar := <i>表达式</i>

    static ClassVar := <i>表达式</i>

    class NestedClass
    {
        ...
    }

    Method()
    {
        ...
    }

    static Method()
    {
        ...
    }

    Property[]  <em>; 方括号是可选的</em>
    {
        <span class="dec">get</span> {
            return <i>属性的值</i>
        }
        <span class="dec">set</span> {
            <i>存储或以其他方式处理</i> <span class="biv">值</span>
        }
    }

     ShortProperty[]
    {
        <span class="dec">get</span> =&gt; <i>计算属性值的表达式</i>
        <span class="dec">set</span> =&gt; <i>存储或以其他方式处理 <span class="biv">值</span> 的表达式</i>
    }

     ShorterProperty[] =&gt; <i>计算属性值的表达式</i>
}
</pre>
<p>加载脚本时, 它构造一个<a href="objects/Class.htm">类</a>对象并将其存储在<a href="Functions.htm#SuperGlobal">超级-全局</a>变量 <i>ClassName</i> 中. 要在<a href="Functions.htm#ForceLocal">强制-局部</a>函数中引用该类, 需要一个声明, 如 <code>global ClassName</code>. 如果存在 <code>extends BaseClassName</code>, 那么 <i>BaseClassName</i> 必须为另一个类的全名. 每个类的全名存储在 <code><i>ClassName</i>.Prototype.__Class</code>.</p>
<p>因为类是通过变量引用的, 类名不能在同一个上下文中同时用于引用类和创建一个单独的变量(比如保存类的一个实例). 例如, <code>box := new Box</code> 将会用其本身的实例替换 <em>Box</em> 中的类对象. <span class="ver">[v1.1.27+]:</span> 每当尝试覆盖一个类时, <a href="commands/_Warn.htm#ClassOverwrite">#Warn ClassOverwrite</a> 允许在加载时显示一个警告.</p>
<p>在本文档中, 单词 "class" 本身通常表示用 <code>class</code> 关键字构造的类对象.</p>
<p>类定义可以包含变量声明, 方法定义和套嵌的类定义.</p>

<h4 id="Custom_Classes_var">实例变量</h4>
<p><em>实例变量</em> 是类的每个实例都拥有独立的副本. 他们如同普通赋值一样被声明, 但 <code>this.</code> 前缀被忽略(仅限于类主体内时):</p>
<pre>InstanceVar := Expression</pre>
<p>These declarations are evaluated each time a new instance of the class is created with the <a href="#Custom_NewDelete">new</a> keyword or <a href="objects/Class.htm#New"><em>ClassName</em>.new()</a>, after all base-class declarations are evaluated but before <a href="#Custom_NewDelete">__New</a> is called. This is achieved by automatically creating a method named <em>__Init</em> containing a call to <code>base.__Init()</code> and inserting each declaration into it. Therefore, a single class definition must not contain both an __Init method and an instance variable declaration.</p>
<p><em>Expression</em> can access other instance variables and methods via <code>this</code>, but all other variable references are assumed to be global.</p>
<p>要访问实例变量, 总是要指定目标对象; 例如, <code><b>this</b>.InstanceVar</code>.</p>
<p>支持形如 <code>x.y := z</code> 的声明语法, 假设 <code>x</code> 已在类中声明. 例如, <code>x := {}, x.y := 42</code> 声明了 <code>x</code> 并初始化了 <code>this.x.y</code>.</p>

<h4 id="Custom_Classes_staticvar">Static/Class 变量</h4>
<p>静态/类变量属于类, but their values can be inherited by subclasses. 和实例变量一样声明, 但使用 static 关键字:</p>
<pre>static ClassVar := Expression</pre>
<p>These declarations are evaluated only once, when the class is initialized. In the current release, classes are initialized in the order that they appear in the script, before evaluation of the <a href="Scripts.htm#auto">auto-execute section</a> and before any static declarations contained by functions. A static method named <em>__Init</em> is automatically defined for this purpose.</p>
<p>Each declaration stores a value in the class object. Any variable references in <i>Expression</i> are assumed to be global.</p>
<p>To assign to a class variable, always specify the class object; for example, <code><b>ClassName</b>.ClassVar := Value</code>. If a subclass does not own a property by that name, <code><i>Subclass</i>.ClassVar</code> can also be used to retrieve the value; so if the value is a reference to an object, subclasses will share that object by default. However, <code><i>Subclass</i>.ClassVar := y</code> would store the value in <em>Subclass</em>, not in <em>ClassName</em>.</p>
<p>支持形如 <code>x.y := z</code> 的声明, 假设 <code>x</code> 已在类中声明. 如: <code>static x:={},x.y:=42</code> 声明了 <code>x</code> 并初始化了<code><i>ClassName</i>.x.y</code>.</p>

<h4 id="Custom_Classes_class">嵌套类</h4>
<p>嵌套类定义允许类对象与外部类的静态/类变量关联, 而不是与单独的全局变量关联. 在上面的例子中, <code>class NestedClass</code> 构造了一个<a href="objects/Class.htm">类</a>对象并将其存储在 <code>ClassName.NestedClass</code>. 子类可以继承 <em>NestedClass</em> 也可以用自己的嵌套类覆盖它(在这种情况下, 可以使用 <code><i>WhichClass</i>.NestedClass.new()</code> 实例化任何合适的类).</p>
<pre>
class NestedClass
{
    ...
}
</pre>
<p>Nesting a class does not imply any particular relationship to the outer class. The nested class is not instantiated automatically, nor do instances of the nested class have any connection with an instance of the outer class, unless the script explicitly makes that connection.</p>

<h4 id="Custom_Classes_method">方法</h4>
<p>方法定义看起来和函数定义相同. 每个方法都有一个名为 <code>this</code> 的隐藏参数, 其中包含对调用该方法的对象的引用. 有两种类型的方法:</p>
<ul>
  <li>Instance methods are defined as below, and are attached to the class's <a href="objects/Class.htm#Prototype">Prototype</a>, which makes them accessible via any instance of the class. When the method is called, <code>this</code> refers to an instance of the class.</li>
  <li>Static methods are defined by preceding the method name with the separate keyword <code>static</code>. These are attached to the class object itself, but are also inherited by subclasses, so <code>this</code> refers to either the class itself or a subclass.</li>
</ul>
<pre>
Method()
{
    ...
}
</pre>

<p id="Custom_Classes_base">在方法的内部, 伪关键字 <code>base</code> 可用于访问在派生类中重写的父类中的方法或属性. 例如, <code>base.Method()</code> 在类定义中将会调用 <em>BaseClassName</em> 中定义的 <em>Method</em> 版本. 除非显式地命名<a href="#Meta_Functions">元函数</a>, 否则不会调用它们. 注意:</p>
<ul>
  <li><code>base.Method()</code> 总是调用基类的当前方法的定义, 即使 <code>this</code> 完全是从那个类派生的 <em>subclass</em> 或其他类派生而来的.</li>
  <li><code>base.Method()</code> 隐式传递 <code>this</code> 作为首个(隐藏)参数.</li>
</ul>
<p><code>base</code> 仅在后面跟着点 <code>.</code> 或方括号 <code>[]</code> 时才有特殊含义, 所以像 <code>obj := base, obj.Method()</code> 这样的代码将不起作用. 通过把 <i>base</i> 赋为非空值可以禁用它的特殊行为, 但是不建议这样做.</p>

<p><a href="Variables.htm#fat-arrow">胖箭头语法</a>可以用来定义一个单行方法, 返回一个表达式:</p>
<pre>Method() =&gt; <i>Expression</i></pre>

<h4 id="Custom_Classes_property">属性</h4>
<s><p>属性定义允许在脚本获取或设置特定键时执行方法.</p></s>
<p>A property definition creates a <a href="objects/Object.htm#DefineProp">dynamic property</a>, which calls a method instead of simply storing or returning a value.</p>
<pre>Property[]  <em>; 方括号是可选的</em>
{
    <span class="dec">get</span> {
        return <i>属性值</i>
    }
    <span class="dec">set</span> {
        <i>存储或以其他方式处理</i> <span class="biv">值</span>
    }
}
</pre>
<p><em>Property</em> 是用户定义的名称, 用于标识属性. 如, <code>obj.Property</code> 将调用 <em>get</em>, 而 <code>obj.Property := value</code> 将调用 <em>set</em>. 在 <em>get</em> 或 <em>set</em> 内, <code>this</code> 指向被引用的对象. <em>set</em>, <code>value</code> 中包含正要赋予的值.</p>
<p>可在属性名右后使用方括号包裹以传递参数, 可用于定义及调用中. 除了使用方括号这点不同, 属性的参数和方法的参数定义方法完全一样 - 可选参数, ByRef 和可变参数也都支持.</p>
<p>Static properties can be defined by preceding the property name with the separate keyword <code>static</code>. In that case, <code>this</code> refers to the class itself or a subclass.</p>
<p><em>set</em> 的返回值会被忽略. 例如, <code>val := obj.Property := 42</code> 总是赋值 <code>val := 42</code> 不管该属性做什么, 除非它抛出异常或退出线程.</p>
<p>每个类可定义部分或完整的属性. 如果一个类覆盖了属性, 可用 <code><a href="#Custom_Classes_base">base.Property</a></code> 访问其基类中定义的属性. 如果没有定义 <em>Get</em> 或 <em>Set</em>, 则可以从基对象继承它. 如果没有定义 <em>Get</em>, 则属性可以返回从基继承的值. 如果在该类和所有基对象中没有定义 <em>Set</em>, 则该属性为只读(尝试设置该属性会抛出异常).</p>
<p>内部 <em>get</em> 与 <em>set</em> 是独立的两方法, 故不可共享变量(除非存储于 <code>this</code> 中).</p>
<p>See also: <a href="objects/Object.htm#DefineProp">DefineProp</a></p>
<p><a href="#Meta_Functions">元函数</a>提供了广泛的控制属性访问, 方法调用的机制, 但更复杂及易错.</p>

<h4 id="Custom_Classes_property_short">胖箭头属性</h4>
<p><a href="Variables.htm#fat-arrow">胖箭头语法</a>可以用来定义 getter 或 setter <a href="#Custom_Classes_property">属性</a>, 它返回一个表达式:</p>
<pre>ShortProperty[]
{
    <span class="dec">get</span> =&gt; <i>计算属性值的表达式</i>
    <span class="dec">set</span> =&gt; <i>存储或以其他方式处理 <span class="biv">值</span> 的表达式</i>
}</pre>
<p>当只定义 getter 时, 大括号和 <code>get</code> 可以省略:</p>
<pre>ShorterProperty[] =&gt; <i>计算属性值的表达式</i></pre>

<h3 id="__Item">__Item 属性</h3>
<p>当索引操作符(数组语法)与对象一起使用时, 将调用 _item 属性. 例如:</p>
<pre>class Env {
    __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

 Env["PATH"] .= ";" A_ScriptDir  <em>; 只影响此脚本和子进程.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> 实际上是一个默认属性名(如果已经定义了这样一个属性):</p>
<ul>
  <li>当有参数时 <code><i>object</i>[<i>params</i>]</code> 等同于 <code><i>object</i>.__Item[<i>params</i>]</code>.</li>
  <li><code><i>object</i>[]</code> 等同于 <code><i>object</i>.__Item</code>.</li>
</ul>
<p>例如:</p>
<pre>
obj := {}
obj[] := Map()     <em>; 等同于 obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Note:</strong> When an explicit property name is combined with empty brackets, as in <code>obj.prop[]</code>, it is handled as two separate operations: first retrieve <code>obj.prop</code>, then invoke the default property of the result. This is part of the language syntax, so is not dependent on the object.</p>

<h3 id="Custom_NewDelete">创建和销毁</h3>
<p>每当使用 <a href="objects/Class.htm#New"><em>ClassName</em>.new()</a> 或 <code>new</code> 关键字创建对象时, 都会调用它的 <code>__New</code> 方法, 以便允许自定义初始化. 传递给 <code>new</code> 的任何参数都会被转发到 <code>__New</code>, 因此可能会影响对象的初始内容或如何构造它.销毁对象时, 则调用 <code>__Delete</code>. 例如:</p>
<pre>m1 := GMem.new(0, 10)
m2 := new GMem(0, 20)
m3 := {base: GMem.Prototype}.__New(0, 30)

<em>; Note: For general memory allocations, use <a href="commands/BufferAlloc.htm">BufferAlloc</a>() instead.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aSize)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aSize, "Ptr")
        if !this.ptr
            throw Exception("Out of memory")
        MsgBox "New GMem of " aSize " bytes at address " this.ptr "."
        return this  <em>; This line is only required if __new is called directly.</em>
    }

    __Delete()
    {
        MsgBox "Delete GMem at address " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<s>__Delete 不可被任何含有 "__Class" 键的对象调用. <a href="#Custom_Classes">Class objects(类对象)</a> 默认包含这个键.</s>
<p>__Delete is not called for any object which owns a property named "__Class". <a href="objects/Class.htm#Prototype">Prototype objects</a> have this property by default.</p>
<p>如果在 __Delete 执行时抛出了异常或运行时错误, 并且未在 __Delete 中处理, 则它就像从一个新<a href="misc/Threads.htm">线程</a>调用 __Delete. 也就是说, 显示一个错误对话框并 __Delete 返回, 但是线程不会退出(除非它已经退出).</p>
<p>Each class may also have a <code>static __New</code> method, which is called immediately after its <a href="#Custom_Classes_staticvar">static variables</a> are initialized (this occurs in the order that classes are defined in the script). This method can be inherited from a base class, and can therefore be used to initialize subclasses. Within <code>static __New</code>, <code>this</code> refers to either the class which defined the method, or a subclass.</p>

<h3 id="Meta_Functions">元函数</h3>
<pre class="Syntax">
class <i>ClassName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Value)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>The name of the property or method.</p></dd>
  <dt>Params</dt>
  <dd><p>An <a href="objects/Array.htm">Array</a> of parameters. This includes only the parameters between <code>()</code> or <code>[]</code>, so may be empty. The meta-function is expected to handle cases such as <code>x.y[z]</code> where <code>x.y</code> is undefined.</p></dd>
  <dt>Value</dt>
  <dd><p>The value being assigned.</p></dd>
</dl>
<p>Meta-functions define what happens when an undefined property or method is invoked. For example, if <code>obj.unk</code> has not been assigned a value, it invokes the <i>__Get</i> meta-function. Similarly, <code>obj.unk := value</code> invokes <i>__Set</i> and <code>obj.unk()</code> invokes <i>__Call</i>.</p>
<p>Properties and methods can be defined in the object itself or any of its <a href="#delegation">base objects</a>. In general, for a meta-function to be called for every property, one must avoid defining any properties. Built-in properties such as <a href="objects/Object.htm#Base">Base</a> can be overridden with a <a href="#Custom_Classes_property">property definition</a> or <a href="objects/Object.htm#DefineProp">DefineProp</a>.</p>
<p>If a meta-function is defined, it must perform whatever default action is required. For example, the following might be expected:</p>
<ul>
  <li><i>Call</i>: Throw an "Unknown method" exception.</li>
  <li>If parameters were given, throw an exception (there's no object to forward the parameters to).</li>
  <li><i>Get</i>: Return an empty string (functions do this by default when <code>return</code> is omitted).</li>
  <li><i>Set</i>: Define a new property with the given value, such as by calling <a href="objects/Object.htm#ObjRawSet">ObjRawSet</a>. </li>
</ul>
<p>Any <a href="objects/Functor.htm">callable object</a> can be used as a meta-function by passing it to <a href="objects/Object.htm#DefineMethod">DefineMethod</a>.</p>
<p>Meta-functions are never called when the property or method name is omitted:</p>
<ul>
  <li>For <code>x[y]</code>, define an <code>__Item</code> property instead (it should accept at least one parameter).</li>
  <li>For <code>%x%()</code>, define a <code>Call</code> method instead.</li>
</ul>

<h4 id="Dynamic_Properties">动态属性</h4>
<p><a href="#Custom_Classes_property">Property syntax</a> and <a href="objects/Object.htm#DefineProp">DefineProp</a> can be used to define properties which compute a value each time they are evaluated, but each property must be defined in advance. By contrast, <em>__Get</em> and <em>__Set</em> can be used to implement properties which are known only at the moment they are invoked.</p>
<p>For example, a "proxy" object could be created which sends requests for properties over the network (or through some other channel). A remote server would send back a response containing the value of the property, and the proxy would return the value to its caller. Even if the name of each property was known in advance, it would not be logical to define each property individually in the proxy class since every property does the same thing (send a network request). Meta-functions receive the property name as a parameter, so are a good solution to this problem.</p>

<h2 id="Default_Base_Object">默认基对象</h2>
<p class="warning"><strong>Note:</strong> This section is out of date, and the default base object will be soon replaced with more specific classes.</p>
<p>当非对象值用于对象语法时, 则调用 <i>默认基对象</i>. 这可以用于调试或为字符串, 数字和/或变量定义全局的类对象行为. 默认基可以使用带任何非对象值的 <code>.base</code> 进行访问; 例如, <code>"".base</code>. 尽管默认基无法像 <code>"".base := Object()</code> 这样进行 <i>set</i>, 不过它可以有自己的基如同在 <code>"".base.base := Object()</code> 中那样.</p>

<h3 id="Automatic_Var_Init">自动初始化变量</h3>
<p>当使用空变量作为 <i>set</i> 运算的目标时, 它直接被传递给 __Set 元函数, 这样它就有机会插入新对象到变量中. 为简洁起见, 此示例不支持多个参数; 如果需要, 可以使用<a href="Functions.htm#Variadic">可变参数函数</a>实现.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    if (var = "")
        var := Object(key, value)
    return var
}</pre>

<h3 id="Pseudo_Properties">伪属性</h3>
<p>对象 "语法糖" 可以适用于字符串和数字.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox A_AhkPath.length.is("int")

Default_Get_PseudoProperty(nonobj, key)
{
    if (key = "length")
        return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    static alias := {int: "integer"}
    return nonobj is (alias[type] or type)
}</pre>
<p>注意也可以使用内置函数, 不过这时不能省略大括号:</p>
<pre>"".base.length := Func("StrLen")
MsgBox A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h3 id="Default__Warn">调试</h3>
<p>默认情况下, 调用非对象值会引发异常. 下面的示例更改行为, 以便显示警告并继续执行脚本:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1:="", p2:="", p3:="", p4:="")
{
    ListLines
    MsgBox "A non-object value was improperly invoked.`n`nSpecifically: " nonobj
    return "" <em>; 通过显式返回覆盖默认行为.</em>
}</pre>

<h2 id="Implementation">实现</h2>
<span id="Refs"></span><h3 id="Reference_Counting">引用计数</h3>
<p>当脚本不再引用对象时, AutoHotkey 使用基本引用计数机制来自动释放对象使用的资源. 脚本作者不应该显式地调用这种机制, 除非打算直接处理未托管的<a href="#Implementation_Pointers">对象的指针</a>.</p>
<p>表达式中的函数, 方法或运算符返回的临时引用在表达式的计算完成或中止后释放. 这允许将临时对象用于资源管理. 例如:</p>
<pre>MsgBox <a href="commands/DllCall.htm">DllCall</a>("GlobalSize", "ptr", (new <a href="#GMem">GMem</a>(0, 20)), "ptr")  <em>; 20</em></pre>
<p>如果希望在对象的最后一个引用被释放后运行一段代码, 可通过 <a href="#Custom_NewDelete">__Delete</a> 元函数实现.</p>
<p><b>已知限制:</b></p>
<ul>
  <li>循环引用必须被打破, 对象才能被释放. 有关详情和例子, 请参阅<a href="#Circular_References">释放对象</a>.</li>
  <li>虽然程序退出时, 静态和全局变量中的引用会自动释放, 但非静态局部变量或表达式求值堆栈中的引用不会. 只有在函数或表达式能够正常完成时, 才会释放这些引用.</li>
</ul>
<p>虽然当程序退出时, 操作系统会回收对象占用的内存, 但是除非释放了对对象的所有引用, 否则不会调用 <a href="#Custom_NewDelete">__Delete</a>. 如果它释放了操作系统不能自动回收的其他资源, 比如临时文件, 那么这一点很重要.</p>

<span id="AddressCast"></span><h3 id="Implementation_Pointers">对象的指针</h3>
<p>在一些罕见的情况中, 可能需要通过 DllCall 传递对象到外部代码或把它存储到二进制数据结构以供以后检索. 可以通过 <code>address := &amp;object</code> 来检索对象的地址; 不过, 这样实际上创建了一个对象的两个引用, 但程序只知道对象中的一个. 如果对象的最后一个 <em>已知</em> 引用被释放, 该对象将被删除. 因此, 脚本必须设法通知对象它的引用增加了. 可以这样做:</p>
<pre><a href="commands/ObjAddRef.htm">ObjAddRef</a>(address := &amp;object)</pre>
<p>脚本还必须在对象使用该引用完成时通知该对象:</p>
<pre><a href="commands/ObjAddRef.htm">ObjRelease</a>(address)</pre>
<p>一般来说, 对象地址的每个新副本都应该被视为对象的另一个引用, 所以脚本必须在获得副本之后立即调用 ObjAddRef, 并在丢弃副本之前立即调用 ObjRelease. 例如, 每当通过类似 <code>x := address</code> 这样复制地址时, 就应该调用一次 ObjAddRef. 同样的, 当脚本使用 <em>x</em> 完时(或者用其他值覆盖 <em>x</em>), 就应该调用一次 ObjRelease.</p>
<p>若要将地址转换为正确的引用, 请使用 Object 函数:</p>
<pre>MyObject := Object(address)</pre>
<p>注意, Object 函数甚至可以在对象创建之前就可以使用, 比如 <a href="commands/ComObjCreate.htm">COM 对象</a>和<a href="objects/File.htm">文件对象</a>.</p>

</body>
</html>