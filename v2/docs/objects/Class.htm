<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>Class 对象 - 方法 &amp; 属性 | AutoHotkey v2</title>
<meta name="description" content="A Class object represents a class definition; it contains static methods and properties." />
<meta name="ahk:equiv-v1" content="AutoHotkey.htm" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
</head>
<body>

<h1>Class 对象</h1>

<p><strong>Class(类)</strong> 对象表示一个类定义; 它包含静态方法和属性.</p>
<p>下面的文档使用 <code>Cls</code> 作为任何类对象的占位符. 注意, "class" 不应该用作变量名, 因为它用于引用类本身. 通常, 通过<a href="../Objects.htm#Custom_Classes">类定义</a>中给出的名称来引用类对象.</p>
<p>每个类对象都<a href="../Objects.htm#Custom_Objects">基于</a>其扩展的任何类, 如果没有指定, 则基于 <a href="Object.htm">Object</a>. <code>Object</code> 基于 <code>Class.Prototype</code>, 其又基于 <code>Object.Prototype</code>, 因此类可以从任何这些基对象继承方法和属性.</p>
<p>"静态" 方法和属性是类对象本身拥有的任何方法和属性(因此不适用于特定实例), 而类实例的方法和属性则由<a href="#Prototype">原型</a>拥有.</p>
<p>类通常具有以下内容:</p>

<p><strong>方法:</strong></p>
<ul>
  <li><a href="#New">New</a></li>
</ul>
<p><strong>属性:</strong></p>
<ul>
  <li><a href="#Prototype">Prototype</a></li>
</ul>

<h2 id="Methods">方法</h2>

<div class="methodShort" id="New"><h2>New</h2>
<p>构造类的新实例.</p>
<pre class="Syntax">Obj := Cls.<span class="func">New</span>(Params*)</pre>
<p>静态方法通常从 <a href="Object.htm">Object</a>, <a href="Array.htm">Array</a> 或 <a href="Map.htm">Map</a> 类继承. 它执行以下功能:</p>
<ul>
  <li>分配内存并初始化对象的二进制结构, 这取决于对象的原生类型(例如, 它是数组还是映射, 或者只是一个对象).</li>
  <li>将新对象的基设置为 <a href="#Prototype">Cls.Prototype</a>.</li>
  <li>如果新对象有 __Init 方法, 则调用它的 __Init 方法. 此方法由类定义自动创建; 它包含类主体中定义的所有实例变量初始化器.</li>
  <li>如果新对象有 __New 方法, 则调用它的 __New 方法. 所有传递给 New 的参数都被转发到 __New.</li>
  <li>返回新对象.</li>
</ul>
<p>New 可以被通过定义静态方法(如 <code>static New()</code>) 在类定义中重写. 这允许类修改或阻止构造新实例.</p>
<p>注意, <code>Class.New()</code> 可用于构造基于 <code>Class.Prototype</code> 的新的 Class 对象. 但是, 新对象最初没有 New 方法, 因为它不是 <a href="Object.htm">Object</a> 的子类. 通过给其 <a href="Object.htm#Base">Base</a> 赋值, 使其成为 Object 的子类, 也可以使用 <a href="Any.htm#GetMethod">GetMethod</a> 和 <a href="Object.htm#DefineMethod">DefineMethod</a> 复制 New 方法. 在使用标准的 New 方法实例化原型之前, 还必须创建原型并将其赋值给该类.</p>
</div>

<h2 id="Properties">属性</h2>

<div class="methodShort" id="Prototype"><h2>Prototype</h2>
<p>检索或设置类的所有实例所基于的对象.</p>
<pre class="Syntax">Proto := Cls.<span class="func">Prototype</span></pre>
<pre class="Syntax">Cls.<span class="func">Prototype</span> := Proto</pre>
<p>默认情况下, 类的原型包含类定义中定义的所有实例方法和动态属性, 可用于检索对方法, 或 getters/setters 属性的引用, 或定义一个新的. 脚本还可以定义新的值属性, 这些值充当所有实例的默认属性值.</p>
<p>原型自动被定义为类定义创建的任何类对象的自身属性.</p>
</div>

</body>
</html>