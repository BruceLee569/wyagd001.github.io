<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Error 对象 | AutoHotkey v2</title>
<meta name="description" content="Error objects thrown by built-in code when an error occurs." />
<meta name="ahk:equiv-v1" content="AutoHotkey.htm" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Error 对象</h1>

<p>Error(错误) 对象是由内置代码在运行时发生错误时<a href="../commands/Throw.htm">抛出的</a>, 也可由脚本显式抛出.</p>

<p id="Message"><strong>Message:</strong> 错误消息.</p>
<p id="What"><strong>What:</strong> 引起异常的原因. 这通常是一个函数的名称, 但对于由表达式中的错误而抛出的异常(例如在非数字值上使用数学运算符), 则为空白.</p>
<p id="Extra"><strong>Extra:</strong> 与错误有关的字符串值(如果有). 如果这个值可以转换为非空字符串, 标准错误对话框会显示一行 "Specifically:" 后面跟着这个字符串.</p>
<p id="File"><strong>File:</strong> 包含发生错误的行或构造错误对象的脚本文件的完整路径.</p>
<p id="Line"><strong>Line:</strong> 错误发生的行号, 或者错误对象被构造的行号.</p>

<p>标准错误对话框要求这些都是值属性, 不能从基对象继承.</p>

<h2 id="new">Error.New() / Exception()</h2>
<p>创建 <a href="../objects/Error.htm">Error</a> 对象.</p>
<pre class="Syntax">NewError := <span class="func"><i>Error</i>.New</span>(Message <span class="optional">, What, Extra</span>)
NewError := <span class="func">Exception</span>(Message <span class="optional">, What, Extra</span>)</pre>
<p><em><strong>Error</strong></em> 可以用 <a href="#error-types">Error 类型</a>中列出的某个子类替换.</p>
<p>这些参数直接对应于上面描述的属性, 但对于覆盖 __New 方法的 Error 子类来说, 参数可能有所不同.</p>
<p>如果省略 <em>What</em>, 则它默认为当前函数的名称. 否则它可以是字符串或调用堆栈顶部的负偏移量. 例如, 值 -1 设置 <code>NewError.What</code> 为当前函数, 并设置 <code>NewError.Line</code> 和 <code>NewError.File</code> 为调用它的行号和文件. 然而, 如果这个脚本已经被<a href="../Scripts.htm#ahk2exe">编译</a>或者偏移是无效的, <em>What</em> 被简单地转换为字符串.</p>
<p>如果由于脚本中的错误(而不是由一个命名的内置函数) 而自动抛出异常, <em>What</em> 通常为空.</p>
<p><em>Message</em> 和 <em>Extra</em>被转换为字符串. 如果一个异常抛出而且没有被捕获, 则会通过一个错误对话框来显示它们.</p>
<pre>try
    SomeFunction()
catch e
    MsgBox(type(e) " in " e.What ", which was called at line " e.Line)

SomeFunction() {
    throw Error.new("Fail", -1)
}</pre>

<h2 id="error-types">Error 类型</h2>

<p><strong>Error</strong> 的以下子类是预定义的:</p>
<ul>
  <li id="IndexError"><strong>IndexError(索引错误)</strong>: 试图使用对象的 <a href="../Objects.htm#__Item">__Item 属性</a>在无效索引处赋值或检索项, 该属性通常通过<a href="../Variables.htm#square-brackets">项访问操作符</a>(也称为索引操作符) 访问.<ul>
    <li id="KeyError"><strong>KeyError</strong>: Map 使用的 IndexError 的子类.</li>
  </ul></li>
  <li id="MemberError"><strong>MemberError(成员错误)</strong>: 试图访问未定义的属性或方法. <strong>Message</strong> 指示要调用的值的类型和属性或方法的名称. 此错误类型不直接使用; 而是使用下面的一个子类.<ul>
    <li id="PropertyError"><strong>PropertyError(属性错误)</strong></li>
    <li id="MethodError"><strong>MethodError(方法错误)</strong></li>
  </ul></li>
  <li id="MemoryError"><strong>MemoryError(内存错误)</strong>: 内存分配失败.</li>
  <li id="OSError"><strong>OSError(系统错误)</strong>: 对 Win32 函数的内部函数调用失败. <strong>Message</strong> 包括操作系统生成的错误码和描述.</li>
  <li id="TargetError"><strong>TargetError(目标错误)</strong>: 函数由于找不到目标而失败. <strong>Message</strong> 指示目标的类型, 例如窗口, 控件, 菜单或状态栏.</li>
  <li id="TimeoutError"><strong>TimeoutError(超时错误)</strong>: <a href="../commands/SendMessage.htm">SendMessage</a> 超时.</li>
  <li id="TypeError"><strong>TypeError(类型错误)</strong>: 意外的值类型被用作函数, 属性赋值或其他操作的输入. 通常 <strong>Message</strong> 指示预期的和实际的类型, 而 <strong>Extra</strong> 包含一个表示错误值的字符串.</li>
  <li id="ValueError"><strong>ValueError(值错误)</strong>: 意外的值被用作函数, 属性赋值或其他操作的输入. 通常 <strong>Message</strong> 指示哪个期望值被打破, 而 <strong>Extra</strong> 包含一个表示错误值的字符串.</li>
  <li id="ZeroDivisionError"><strong>ZeroDivisionError(零除错误)</strong>: 在表达式或 Mod 函数中试图除以零.</li>
</ul>
<p>也可以使用基 Error 类来抛出 Error.</p>

<h2 id="Related">相关</h2>
<p><a href="../commands/Throw.htm">Throw</a>, <a href="../commands/Try.htm">Try</a>, <a href="../commands/Catch.htm">Catch</a>, <a href="../commands/Finally.htm">Finally</a>, <a href="../commands/OnError.htm">OnError</a></p>

</body>
</html>