<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>InputHook - 语法 &amp; 使用 | AutoHotkey v2</title>
<meta name="description" content="The InputHook function creates an object which can be used to collect or intercept keyboard input." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
</head>
<body>

<h1>InputHook</h1>

<p>创建一个对象, 该对象可用于收集或拦截键盘输入.</p>

<pre class="Syntax">InputHook := <span class="func">InputHook</span>(<span class="optional">Options, EndKeys, MatchList</span>)</pre>
<h2>Parameters</h2>
<dl>

  <dt>Options</dt>
  <dd>
    <p><u>由零个或多个下列字母组成的字符串(可任意顺序, 中间可选空格):</u></p>
    <p id="option-b"><strong>B</strong>: 设置 <a href="#BackspaceIsUndo">BackspaceIsUndo</a> 为 false, 这会导致 <kbd>Backspace</kbd> 被忽略.</p>
    <p id="option-c"><strong>C</strong>: 设置 <a href="#CaseSensitive">CaseSensitive</a> 为 true, 使 <em>MatchList</em> 区分大小写.</p>
    <p id="option-i"><strong>I</strong>: 设置 <a href="#MinSendLevel">MinSendLevel</a> 为 1 或给定值, 使任何<a href="SendLevel.htm">输入级别</a>低于该值的输入被忽略. 例如, <code>I2</code> 将忽略级别为 0(默认值) 或 1 的任何输入, 但将捕获级别为 2 的输入.</p>
    <p id="option-l"><strong>L</strong>: 长度限制(例如 <code>L5</code>). 输入的最大允许长度. 当文本达到这个长度时, 输入被终止, EndReason 被设置为单词 Max(除非文本匹配 <em>MatchList</em> 中的一个短语, 在这种情况下 EndReason 被设置为单词 Match). 如果未指定, 则长度限制为 1023.</p>
    <p>指定 <code>L0</code> 禁用文本的收集和长度限制, 但并不影响按键生成的文本的统计(请参阅 <a href="#VisibleText">VisibleText</a>). 这可以与 <a href="#OnChar">OnChar</a>, <a href="#OnKeyDown">OnKeyDown</a>, <a href="#KeyOpt">KeyOpt</a> 或 <em><a href="#EndKeys">EndKeys</a></em> 组合使用.</p>
    <p id="option-m"><strong>M</strong>: 将修饰键击对应于真正的 ASCII 字符, 识别并转录修饰键击(如 <kbd>Control</kbd>+<kbd>A</kbd> 到 <kbd>Control</kbd>+<kbd>Z</kbd>). 参考这个例子, 它识别 <kbd>Control</kbd>+<kbd>C</kbd>:</p>
    <pre>CtrlC := Chr(3) <em>; 将 Ctrl-C 对应的字符存储在 CtrlC 变量中.</em>
ih := InputHook("L1 M")
ih.Start()
ih.Wait()
if (ih.Input = CtrlC)
    MsgBox "You pressed Control-C."</pre>
    <p class="note"><strong>注意</strong>: 字符 <kbd>Ctrl</kbd>+<kbd>A</kbd> 到 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 对应于 <a href="Chr.htm">Chr(1)</a> 到 <a href="Chr.htm">Chr(26)</a>. 此外, <strong>M</strong> 选项可能会导致某些键盘快捷键(如 <kbd>Ctrl</kbd>+<kbd>&larr;</kbd>) 在输入正在进行时出现异常.</p>
    <p id="option-t"><strong>T</strong>: 设置 <a href="#Timeout">Timeout</a> (例如 <code>T3</code> 或 <code>T2.5</code>).</p>
    <p id="vis"><strong>V</strong>: 设置 <a href="#VisibleText">VisibleText</a> 和 <a href="#VisibleNonText">VisibleNonText</a> 为 true. 通常, 用户的输入被阻止(对系统隐藏). 使用此选项可将用户的击键发送到活动窗口.</p>
    <p id="asterisk"><strong>*</strong>: 通配符. 设置 <a href="#FindAnywhere">FindAnywhere</a> 为 true, 允许在用户键入的任何位置找到匹配项.</p>
    <p id="E"><strong>E</strong>: 按字符代码而不是键码处理单字符结束键.  如果活动窗口的键盘布局与脚本的键盘布局不同, 则可以提供更一致的结果. 它还可以防止实际上不会产生给定结束字符的键组合结束 Input(输入); 例如, 如果 <code>@</code> 是结束键, 则在美式键盘中 <kbd>Shift</kbd>+<kbd>2</kbd> 将触发它, 但 <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>2</kbd> 不会触发(在使用 E 选项时). 如果还使用 <strong>C</strong> 选项, 则结束字符区分大小写.</p>
  </dd>

  <dt id="EndKeys">EndKeys</dt>
  <dd>
    <p>一个由零个或多个按键组成的列表, 其中任何一个键在按下时终止输入(结束键本身不会写入输入缓冲). 当 Input 以这种方式终止时, EndReason 设置为单词 EndKey, <a href="#EndKey">EndKey</a> 属性设置为键的名称.</p>
    <p><em>EndKeys</em> 列表使用类似于 <a href="Send.htm">Send</a> 函数的格式. 例如, 指定 <code>{Enter}.{Esc}</code> 将使 <kbd>Enter</kbd>, <kbd>.</kbd> 或 <kbd>Escape</kbd> 任一一个都能终止 Input. 使用大括号本身作为结束键, 指定 <code>{{}</code> 和/或 <code>{}}</code>.</p>
    <p>要使用 <kbd>Control</kbd>, <kbd>Alt</kbd> 或 <kbd>Shift</kbd> 作为结束键, 请指定键的左和/或右的版本, 而不是中性版本. 例如, 指定 <code>{LControl}{RControl}</code> 而不是 <code>{Control}</code>.</p>
    <p>尽管不支持诸如 <kbd>Alt</kbd>+<kbd>C</kbd>(!c) 这样的修饰键, 而非-字母数字字符(如 <code>?!:@&amp;{}</code>) 默认情况下需要 Shift 按键按下与否, 取决于字符的正常输入方式. 如果有 <strong>E</strong> 选项, 则将单个字符键名解释为字符, 在这种情况下, 修饰符键必须处于正确的状态才能生成该字符. 当同时使用 <strong>E</strong> 和 <strong>M</strong> 选项时, 通过在 <em>EndKeys</em> 中包括相应的 ASCII 控制字符来支持 <kbd>Control</kbd>+<kbd>A</kbd> 到 <kbd>Control</kbd>+<kbd>Z</kbd>.</p>
    <p>还可以指定明确的虚拟按键代码, 例如 <code>{vkFF}</code> 或 <code>{sc001}</code>. 这在键没有名称且按下时不产生可见字符的罕见情况下非常有用. 它的虚拟键码可以通过<a href="../KeyList.htm#SpecialKeys">按键列表页面</a>底部的步骤来确定.</p>
  </dd>

  <dt id="MatchList">MatchList</dt>
  <dd>
    <p>以逗号分隔的关键词列表, 其中任何一个都将导致终止输入(在这种情况下, EndReason 将被设置为单词 Match). 用户输入的内容必须完全匹配匹配列表中的某个词组(除非有 <a href="#asterisk">* 选项</a>). 此外, <strong>分隔符逗号周围的任何空格或制表符都是有意义的</strong>, 这意味着它们是匹配字符串的一部分. 例如, 如果 <em>MatchList</em> 为 <code>ABC , XYZ</code>, 则用户必须在 ABC 之后或 XYZ 之前键入空格以形成匹配.</p>
    <p>两个连续的逗号产生单个原义逗号. 例如, 后面的匹配列表会在 string1 的末尾产生单个原义逗号: <code>string1,,,string2</code>. 类似的, 后面的匹配列表仅包含其中有一个原义逗号的单个项目: <code>single,,item</code>.</p>
    <p>因为 <em>MatchList</em> 中的项目不被视为单独的参数, 所以列表可以完全包含在一个变量中. 事实上, 如果此列表的长度超过 16383, 那么列表的全部或部分必须包含在变量中, 因为这个长度是任何脚本行的最大长度. 例如, <em>MatchList</em> 可能由 <code>%List1%,%List2%,%List3%</code> 组成 -- 其中每个变量都包含匹配词组的子列表.</p>
  </dd>

</dl>

<h2 id="stack">Input 堆栈</h2>
<p>任何数量的 InputHook 对象都可以在任何时候创建和进行, 但是它们启动的顺序会影响 Input 的收集方式.</p>
<p>当每个 Input 开始时(通过 <a href="#Start">Start</a> 方法或 <a href="Input.htm">Input</a> 函数), 它被推到堆栈的顶部, 只有当 Input 终止时才从堆栈中删除. 键盘事件按最近开始到最早的顺序传递给每个输入. 如果一个输入抑制了一个给定的键盘事件, 那么它就不会再向下传递.</p>
<p>如果击键的<a href="SendLevel.htm">发送级别</a>低于 InputHook 的 <a href="#MinSendLevel">MinSendLevel</a>, 则忽略 <a href="Send.htm">Sent</a> 的击键. 在这种情况下, 击键仍然可以由堆栈中较低的输入来处理.</p>
<p>多个 InputHook 都可以与 <a href="#MinSendLevel">MinSendLevel</a> 一起使用, 以分别收集发送的击键和实际击键.</p>
<p>调用 <a href="Input.htm">Input</a> 函数将终止任何由先前的 Input 函数启动的输入, 但保留任何活动的 InputHook. 如果输入 <a href="Input.htm#vis">visible(不可见)</a>, 它中断的任何 InputHook 通常不会收集任何输入, 直到 Input 函数返回.</p>

<h2 id="object">InputHook 对象</h2>
<p>InputHook 函数返回一个 InputHook 对象, 该对象具有以下方法和属性.</p>
<p>方法:</p>
<ul>
  <li><a href="#KeyOpt">KeyOpt</a>: 设置按键或按键列表的选项.</li>
  <li><a href="#Start">Start</a>: 启动收集输入.</li>
  <li><a href="#Stop">Stop</a>: 终止 Input 并将 EndReason 设置为单词 Stopped.</li>
  <li><a href="#Wait">Wait</a>: 等待, 直到 Input 终止(InProgress 为 false).</li>
</ul>
<p>常规属性:</p>
<ul>
  <li><a href="#EndKey">EndKey</a>: 返回终止 Input 而按下的<a href="#EndKeys">结束建</a>的名称.</li>
  <li><a href="#EndMods">EndMods</a>: 返回在 Input 终止时逻辑上是按下的修饰符键的字符串.</li>
  <li><a href="#EndReason">EndReason</a>: 返回 <a href="#EndReasons">EndReason 字符串</a>, 该字符串表明了 Input 是如何终止的.</li>
  <li><a href="#InProgress">InProgress</a>: 如果输入正在进行, 则返回 true, 否则返回 false.</li>
  <li><a href="#Input">Input</a>: 返回自上次 Input 启动以来收集的任何文本.</li>
  <li><a href="#Match">Match</a>: 返回导致 Input 终止的 <em>MatchList</em> 项目.</li>
  <li><a href="#OnEnd">OnEnd</a>: 检索或设置在 Input 终止时调用的<a href="../objects/Functor.htm">函数对象</a>.</li>
  <li><a href="#OnChar">OnChar</a>: 检索或设置<a href="../objects/Functor.htm">函数对象</a>, 该函数对象将在字符添加到输入缓冲后调用.</li>
  <li><a href="#OnKeyDown">OnKeyDown</a>: 检索或设置<a href="../objects/Functor.htm">函数对象</a>, 该函数对象将在按下启用通知的按键时调用.</li>
</ul>
<p>选项属性:</p>
<ul>
  <li><a href="#BackspaceIsUndo">BackspaceIsUndo</a>: 控制 <kbd>Backspace</kbd> 是否从输入缓冲的末尾删除最近按下的字符.</li>
  <li><a href="#CaseSensitive">CaseSensitive</a>: 控制 <em>MatchList</em> 是否区分大小写.</li>
  <li><a href="#FindAnywhere">FindAnywhere</a>: 控制每个匹配项是否可以是输入文本的子字符串.</li>
  <li><a href="#MinSendLevel">MinSendLevel</a>: 检索或设置要收集的输入的最小<a href="SendLevel.htm">发送级别</a>.</li>
  <li><a href="#NotifyNonText">NotifyNonText</a>: 控制当按下非文本键时是否调用 <a href="#OnKeyDown">OnKeyDown</a> 回调.</li>
  <li><a href="#Timeout">Timeout</a>: 检索或设置超时值(以秒为单位).</li>
  <li><a href="#VisibleNonText">VisibleNonText</a>: 控制不产生文本的键或键组合是否可见(不阻止).</li>
  <li><a href="#VisibleText">VisibleText</a>: 控制产生文本的键或键组合是否可见(不阻止).</li>
</ul>

<div class="methodShort" id="KeyOpt"><h2>KeyOpt</h2>
<p>Sets options for a key or list of keys.</p>
<pre class="Syntax">InputHook.<span class="func">KeyOpt</span>(Keys, KeyOptions)</pre>
<dl>
  <dt>Keys</dt>
  <dd><p>A list of keys. Braces are used to enclose key names, virtual key codes or scan codes, similar to the <a href="Send.htm">Send</a> function. For example, <code>{Enter}.{{}</code> would apply to the <kbd>Enter</kbd>, <kbd>.</kbd> and <kbd>{</kbd> keys. Specifying a key by name, by <code>{vkNN}</code> or by <code>{scNNN}</code> may produce three different results; see below for details.</p>
  <p id="all-keys">Specify the string <code>{All}</code> (case-insensitive) on its own to apply <em>KeyOptions</em> to all VK and all SC. KeyOpt may then be called a second time to remove options from specific keys.</p></dd>
  <dt>KeyOptions</dt>
  <dd><p>One or more of the following single-character options (spaces and tabs are ignored).</p>
  <p id="KeyOpt-minus"><strong>-</strong> (minus): Removes any of the options following the <code>-</code>, up to the next <code>+</code>.</p>
  <p id="KeyOpt-plus"><strong>+</strong> (plus): Cancels any previous <code>-</code>, otherwise has no effect.</p>
  <p id="KeyOpt-e"><strong>E</strong>: End key. If enabled, pressing the key terminates Input, sets <a href="#EndReason">EndReason</a> to the word EndKey and the <a href="#EndKey">EndKey</a> property to the key's normalized name. Unlike the <em>EndKeys</em> parameter, the state of the Shift key is ignored. For example, <code>@</code> and <code>2</code> are both equivalent to <code>{vk32}</code> on the US keyboard layout.</p>
  <p id="KeyOpt-i"><strong>I</strong>: Ignore text. Any text normally produced by this key is ignored, and the key is treated as a non-text key (see <a href="#VisibleNonText">VisibleNonText</a>). Has no effect if the key normally does not produce text.</p>
  <p id="KeyOpt-n"><strong>N</strong>: Notify. Causes the <a href="#OnKeyDown">OnKeyDown</a> callback to be called each time the key is pressed.</p>
  <p id="KeyOpt-s"><strong>S</strong>: Suppresses (blocks) the key after processing it. This overrides <a href="#VisibleText">VisibleText</a> or <a href="#VisibleNonText">VisibleNonText</a> until <code>-S</code> is used. <code>+S</code> implies <code>-V</code>.</p>
  <p id="KeyOpt-v"><strong>V</strong>: Visible. Prevents the key from being suppressed (blocked). This overrides <a href="#VisibleText">VisibleText</a> or <a href="#VisibleNonText">VisibleNonText</a> until <code>-V</code> is used. <code>+V</code> implies <code>-S</code>.</p>
  </dd>
</dl>
<p id="KeyOpt-remarks">Options can be set by both virtual key code and scan code, and are accumulative.</p>
<p>When a key is specified by name, the options are set either by VK or by SC. Where two physical keys share the same VK but differ by SC (such as <kbd>Up</kbd> and <kbd>NumpadUp</kbd>), they are handled by SC. By contrast, if a VK number is used, it will apply to any physical key which produces that VK (and this may vary over time as it depends on the active keyboard layout).</p>
<p>Removing an option by VK number does not affect any options that were set by SC, or vice versa. However, when an option is removed by key name and that name is handled by VK, the option is also removed for the corresponding SC (according to the script's keyboard layout). This allows keys to be excluded by name after applying an option to <a href="#all-keys">all keys</a>.</p>
<p>If <code>+V</code> is set by VK and <code>+S</code> is set by SC (or vice versa), <code>+V</code> takes precedence.</p>
</div>

<div class="methodShort" id="Start"><h2>Start</h2>
<p>Starts collecting input.</p>
<pre class="Syntax">InputHook.<span class="func">Start</span>()</pre>
<p>Has no effect if the Input is already in progress.</p>
<p>The newly started Input is placed on the top of the <a href="#stack">InputHook stack</a>, which allows it to override any previously started Input.</p>
<p>This method installs the <a href="_InstallKeybdHook.htm">keyboard hook</a> (if it was not already).</p>
</div>

<div class="methodShort" id="Wait"><h2>Wait</h2>
<p>Waits until the Input is terminated (<a href="#InProgress">InProgress</a> is false).</p>
<pre class="Syntax">InputHook.<span class="func">Wait</span>(<span class="optional">MaxTime</span>)</pre>
<dl>
  <dt>MaxTime</dt>
  <dd><p>The maximum number of seconds to wait. If Input is still in progress after <em>MaxTime</em> seconds, the method returns and does not terminate Input.</p></dd>
</dl>
<p><strong>Returns</strong> <a href="#EndReason">EndReason</a>.</p>
</div>

<div class="methodShort" id="Stop"><h2>Stop</h2>
<p>Terminates the Input and sets <a href="#EndReason">EndReason</a> to the word Stopped.</p>
<pre class="Syntax">InputHook.<span class="func">Stop</span>()</pre>
<p>Has no effect if the Input is not in progress.</p>
</div>

<div class="methodShort" id="EndKey"><h2>EndKey</h2>
<p>Returns the name of the <a href="#EndKeys">end key</a> which was pressed to terminate the Input.</p>
<pre class="Syntax">KeyName := InputHook.EndKey</pre>
<p>Note that EndKey returns the "normalized" name of the key regardless of how it was written in <em>EndKeys</em>. For example, <code>{Esc}</code> and <code>{vk1B}</code> both produce <code>Escape</code>. <a href="GetKeyName.htm">GetKeyName</a> can be used to retrieve the normalized name.</p>
<p>If the <a href="#E">E option</a> was used, EndKey returns the actual character which was typed (if applicable). Otherwise, the key name is determined according to the script's active keyboard layout.</p>
<p>EndKey returns an empty string if <a href="#EndReason">EndReason</a> is not "EndKey".</p>
</div>

<div class="methodShort" id="EndMods"><h2>EndMods</h2>
<p>Returns a string of the modifiers which were logically down when Input was terminated.</p>
<pre class="Syntax">Mods := InputHook.EndMods</pre>
<p>If all modifiers were logically down (pressed), the full string is:</p>
<pre>&lt;^&gt;^&lt;!&gt;!&lt;+&gt;+&lt;#&gt;#</pre>
<p>These modifiers have the same meaning as with <a href="../Hotkeys.htm">hotkeys</a>. Each modifier is always qualified with &lt; (left) or &gt; (right). The corresponding key names are: LCtrl, RCtrl, LAlt, RAlt, LShift, RShift, LWin, RWin.</p>
<p><a href="InStr.htm">InStr</a> can be used to check whether a given modifier (such as <code>&gt;!</code> or <code>^</code>) is present. The following line can be used to convert <em>Mods</em> to a string of neutral modifiers, such as <code>^!+#</code>:</p>
<pre>Mods := RegExReplace(Mods, "[&lt;&gt;](.)(?:&gt;\1)?", "$1")</pre>
<p>Due to split-second timing, this property may be more reliable than <a href="GetKeyState.htm">GetKeyState</a> even if it is used immediately after Input terminates, or in the <a href="#OnEnd">OnEnd</a> callback.</p>
</div>

<div class="methodShort" id="EndReason"><h2>EndReason</h2>
<p>Returns an <a href="#EndReasons">EndReason string</a> indicating how Input was terminated.</p>
<pre class="Syntax">Reason := InputHook.EndReason</pre>
<p>Returns an empty string if the Input is still in progress.</p>
</div>

<div class="methodShort" id="InProgress"><h2>InProgress</h2>
<p>Returns true if the Input is in progress and false otherwise.</p>
<pre class="Syntax">Boolean := InputHook.InProgress</pre>
</div>

<div class="methodShort" id="Input"><h2>Input</h2>
<p>Returns any text collected since the last time Input was started.</p>
<pre class="Syntax">String := InputHook.Input</pre>
<p>This property can be used while the Input is in progress, or after it has ended.</p>
</div>

<div class="methodShort" id="Match"><h2>Match</h2>
<p>Returns the <em><a href="#MatchList">MatchList</a></em> item which caused the Input to terminate.</p>
<pre class="Syntax">String := InputHook.Match</pre>
<p><strong>Returns</strong> the matched item with its original case, which may differ from what the user typed if the <strong>C</strong> option was omitted. Returns an empty string if <a href="#EndReason">EndReason</a> is not "Match".</p>
</div>

<div class="methodShort" id="OnEnd"><h2>OnEnd</h2>
<p>Retrieves or sets the <a href="../objects/Functor.htm">function object</a> which is called when Input is terminated.</p>
<pre class="Syntax">MyFunc := InputHook.OnEnd</pre>
<pre class="Syntax">InputHook.OnEnd := MyFunc</pre>
<p>Type: <a href="../objects/Functor.htm">function object</a> or <a href="../Concepts.htm#nothing">empty string</a>. Default: empty string.</p>
<p>The function is passed one parameter: a reference to the InputHook object.</p>
<p>The function is called as a new <a href="../misc/Threads.htm">thread</a>, so starts off fresh with the default values for settings such as <a href="SendMode.htm">SendMode</a> and <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>.</p>
</div>

<div class="methodShort" id="OnChar"><h2>OnChar</h2>
<p>Retrieves or sets the <a href="../objects/Functor.htm">function object</a> which is called after a character is added to the input buffer.</p>
<pre class="Syntax">MyFunc := InputHook.OnChar</pre>
<pre class="Syntax">InputHook.OnChar := MyFunc</pre>
<p>Type: <a href="../objects/Functor.htm">function object</a> or <a href="../Concepts.htm#nothing">empty string</a>. Default: empty string.</p>
<p>The function is passed the following parameters: <code>InputHook, Char</code>. <em>Char</em> is a string containing the character or characters.</p>
<p>The presence of multiple characters indicates that a dead key was used prior to the last keypress, but the two keys could not be transliterated to a single character. For example, on some keyboard layouts <kbd>`</kbd><kbd>e</kbd> produces <code>è</code> while <kbd>`</kbd><kbd>z</kbd> produces <code>`z</code>.</p>
<p>The function is never called when an end key is pressed.</p>
</div>

<div class="methodShort" id="OnKeyDown"><h2>OnKeyDown</h2>
<p>Retrieves or sets the <a href="../objects/Functor.htm">function object</a> which is called when a notification-enabled key is pressed.</p>
<pre class="Syntax">MyFunc := InputHook.OnKeyDown</pre>
<pre class="Syntax">InputHook.OnKeyDown := MyFunc</pre>
<p>Type: <a href="../objects/Functor.htm">function object</a> or <a href="../Concepts.htm#nothing">empty string</a>. Default: empty string.</p>
<p>Key-down notifications must first be enabled by <a href="#KeyOpt">KeyOpt</a> or <a href="#NotifyNonText">NotifyNonText</a>.</p>
<p>The function is passed the following parameters: <code>InputHook, VK, SC</code>. <em>VK</em> and <em>SC</em> are integers. To retrieve the key name (if any), use <code>GetKeyName(Format("vk{:x}sc{:x}", VK, SC))</code>.</p>
<p>The function is called as a new <a href="../misc/Threads.htm">thread</a>, so starts off fresh with the default values for settings such as <a href="SendMode.htm">SendMode</a> and <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>.</p>
<p>The function is never called when an end key is pressed.</p>
</div>

<div class="methodShort" id="BackspaceIsUndo"><h2>BackspaceIsUndo</h2>
<p>Controls whether <kbd>Backspace</kbd> removes the most recently pressed character from the end of the Input buffer.</p>
<pre class="Syntax">Boolean := InputHook.BackspaceIsUndo</pre>
<pre class="Syntax">InputHook.BackspaceIsUndo := Boolean</pre>
<p>Type: <a href="../Concepts.htm#boolean">Integer (boolean)</a>. Default: true. Option <strong>B</strong> sets the value to false.</p>
<p>When <kbd>Backspace</kbd> acts as undo, it is treated as a text entry key. Specifically, whether the key is suppressed depends on <a href="#VisibleText">VisibleText</a> rather than <a href="#VisibleNonText">VisibleNonText</a>.</p>
<p><kbd>Backspace</kbd> is always ignored if pressed in combination with a modifier key such as <kbd>Ctrl</kbd> (the logical modifier state is checked rather than the physical state).</p>
<p class="warning"><strong>Note:</strong> If the input text is visible (such as in an editor) and the arrow keys or other means are used to navigate within it, <kbd>Backspace</kbd> will still remove the last character rather than the one behind the caret (insertion point).</p>
</div>

<div class="methodShort" id="CaseSensitive"><h2>CaseSensitive</h2>
<p>Controls whether <em>MatchList</em> is case sensitive.</p>
<pre class="Syntax">Boolean := InputHook.CaseSensitive</pre>
<pre class="Syntax">InputHook.CaseSensitive := Boolean</pre>
<p>Type: <a href="../Concepts.htm#boolean">Integer (boolean)</a>. Default: false. Option <strong>C</strong> sets the value to true.</p>
</div>

<div class="methodShort" id="FindAnywhere"><h2>FindAnywhere</h2>
<p>Controls whether each match can be a substring of the input text.</p>
<pre class="Syntax">Boolean := InputHook.FindAnywhere</pre>
<pre class="Syntax">InputHook.FindAnywhere := Boolean</pre>
<p>Type: <a href="../Concepts.htm#boolean">Integer (boolean)</a>. Default: false. Option <strong>*</strong> sets the value to true.</p>
<p>If true, a match can be found anywhere within what the user types (the match can be a substring of the input text). If false, the entirety of what the user types must match one of the <em>MatchList</em> phrases. In both cases, one of the <em>MatchList</em> phrases must be typed in full.</p>
</div>

<div class="methodShort" id="MinSendLevel"><h2>MinSendLevel</h2>
<p>Retrieves or sets the minimum <a href="SendLevel.htm">send level</a> of input to collect.</p>
<pre class="Syntax">Level := InputHook.MinSendLevel</pre>
<pre class="Syntax">InputHook.MinSendLevel := Level</pre>
<p>Type: <a href="../Concepts.htm#numbers">Integer</a>. Default: 0. Option <strong>I</strong> sets the value to 1 (or a given value).</p>
<p><em>Level</em> should be an integer between 0 and 101. Events which have a send level <em>lower</em> than this value are ignored. For example, a value of 101 causes all input generated by <a href="Send.htm">SendEvent</a> to be ignored, while a value of 1 only ignores input at the default send level (zero).</p>
<p>The <a href="Send.htm#SendInput">SendInput</a> and <a href="Send.htm#SendPlay">SendPlay</a> methods are always ignored, regardless of this setting. Input generated by any source other than AutoHotkey is never ignored as a result of this setting.</p>
</div>

<div class="methodShort" id="NotifyNonText"><h2>NotifyNonText</h2>
<p>Controls whether the <a href="#OnKeyDown">OnKeyDown</a> callback is called whenever a non-text key is pressed.</p>
<pre class="Syntax">Boolean := InputHook.NotifyNonText</pre>
<pre class="Syntax">InputHook.NotifyNonText := Boolean</pre>
<p>Type: <a href="../Concepts.htm#boolean">Integer (boolean)</a>. Default: false.</p>
<p>Setting this to true enables notifications for all keypresses which do not produce text, such as when pressing <kbd>Left</kbd> or <kbd>Alt</kbd>+<kbd>F</kbd>. Setting this property does not affect a key's <a href="#KeyOpt">options</a>, since the production of text depends on the active window's keyboard layout at the time the key is pressed. </p>
<p>See <a href="#VisibleText">VisibleText</a> for details about which keys are counted as producing text.</p>
</div>

<div class="methodShort" id="Timeout"><h2>Timeout</h2>
<p>Retrieves or sets the timeout value in seconds.</p>
<pre class="Syntax">Seconds := InputHook.Timeout</pre>
<pre class="Syntax">InputHook.Timeout := Seconds</pre>
<p>Type: <a href="../Concepts.htm#numbers">Float</a>. Default: 0.0 (none). Option <strong>T</strong> also sets the timeout value.</p>
<p>The timeout period ordinarily starts when <a href="#Start">Start</a> is called, but will restart if this property is assigned a value while Input is in progress. If Input is still in progress when the timeout period elapses, it is terminated and <a href="#EndReason">EndReason</a> is set to the word Timeout.</p>
</div>

<div class="methodShort" id="VisibleNonText"><h2>VisibleNonText</h2>
<p>Controls whether keys or key combinations which do not produce text are visible (not blocked).</p>
<pre class="Syntax">Boolean := InputHook.VisibleNonText</pre>
<pre class="Syntax">InputHook.VisibleNonText := Boolean</pre>
<p>Type: <a href="../Concepts.htm#boolean">Integer (boolean)</a>. Default: true. Option <strong>V</strong> sets the value to true.</p>
<p>If true, keys and key combinations which do not produce text may trigger hotkeys or be passed on to the active window. If false, they are blocked.</p>
<p>See <a href="#VisibleText">VisibleText</a> for details about which keys are counted as producing text.</p>
</div>

<div class="methodShort" id="VisibleText"><h2>VisibleText</h2>
<p>Controls whether keys or key combinations which produce text are visible (not blocked).</p>
<pre class="Syntax">Boolean := InputHook.VisibleText</pre>
<pre class="Syntax">InputHook.VisibleText := Boolean</pre>
<p>Type: <a href="../Concepts.htm#boolean">Integer (boolean)</a>. Default: false. Option <strong>V</strong> sets the value to true.</p>
<p>If true, keys and key combinations which produce text may trigger hotkeys or be passed on to the active window. If false, they are blocked.</p>
<p>Any keystrokes which cause text to be appended to the Input buffer are counted as producing text, even if they do not normally do so in other applications. For instance, <kbd>Ctrl</kbd>+<kbd>A</kbd> produces text if the <a href="#option-m"><strong>M</strong> option</a> is used, and <kbd>Escape</kbd> produces the control character <code>Chr(27)</code>.</p>
<p>Dead keys are counted as producing text, although they do not typically produce an immediate effect. Pressing a dead key might also cause the following key to produce text (if only the dead key's character).</p>
<p><kbd>Backspace</kbd> is counted as producing text only when it <a href="#BackspaceIsUndo">acts as undo</a>.</p>
<p>The <a href="../KeyList.htm#modifier">standard modifier keys</a> and CapsLock, NumLock and ScrollLock are always visible (not blocked).</p>
</div>

<h2 id="EndReasons">EndReason</h2>
<p>The EndReason property returns one of the following strings:</p>
<table class="info">
  <tr>
    <td>Stopped</td>
    <td>The Stop method was called or Start has not yet been called for the first time.</td>
  </tr>
  <tr>
    <td>Max</td>
    <td>The Input reached the maximum allowed length and it does not match any of the items in <em>MatchList</em>.</td>
  </tr>
  <tr>
    <td>Timeout</td>
    <td>The Input timed out.</td>
  </tr>
  <tr>
    <td>Match</td>
    <td>The Input matches one of the items in <em>MatchList</em>. The <a href="#Match">Match</a> property contains the matched item.</td>
  </tr>
  <tr>
    <td>EndKey</td>
    <td>
      <p>One of the <em>EndKeys</em> was pressed to terminate the Input. The <a href="#EndKey">EndKey</a> property contains the terminating key name or character without braces.</p>
    </td>
  </tr>
  <tr>
    <td></td>
    <td>If the Input is in progress, EndReason is blank.</td>
  </tr>
</table>

<h2 id="Remarks">Remarks</h2>
<p>The <a href="#Start">Start</a> method must be called before input will be collected.</p>
<p>InputHook is designed to allow different parts of the script to monitor input, with minimal conflicts. It can operate continuously, such as to watch for <a href="#ExSac">arbitrary words</a> or other patterns. It can also operate temporarily, such as to collect user input or temporarily override specific (or <a href="#ExKeyWaitAny">non-specific</a>) keys without interfering with hotkeys.</p>
<p>Keyboard <a href="../Hotkeys.htm">hotkeys</a> are still in effect while an Input is in progress, but cannot be triggered by keys which the Input suppresses.</p>
<p>Keys are either suppressed (blocked) or not depending on the following factors (in order):</p>
<ul>
  <li>If the <a href="#KeyOpt-v">V option</a> is in effect for this VK or SC, it is not suppressed.</li>
  <li>If the <a href="#KeyOpt-s">S option</a> is in effect for this VK or SC, it is suppressed.</li>
  <li>If the key is a <a href="../KeyList.htm#modifier">standard modifier key</a> or CapsLock, NumLock or ScrollLock, it is not suppressed.</li>
  <li><a href="#VisibleText">VisibleText</a> or <a href="#VisibleNonText">VisibleNonText</a> is consulted, depending on whether the key produces text. If the property is false, the key is suppressed.   See <a href="#VisibleText">VisibleText</a> for details about which keys are counted as producing text.</li>
</ul>
<p>The <a href="_InstallKeybdHook.htm">keyboard hook</a> is required while an Input is in progress, but will be uninstalled automatically if it is no longer needed when the Input is terminated. The presence of the keyboard hook causes the script to become temporarily <a href="_Persistent.htm">persistent</a>, meaning that <a href="ExitApp.htm">ExitApp</a> may be needed to terminate it.</p>
<p>AutoHotkey does not support Input Method Editors (IME). The keyboard hook intercepts keyboard events and translates them to text by using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-tounicodeex">ToUnicodeEx</a> or ToAsciiEx (except in the case of <a href="https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes#vk_packet">VK_PACKET</a> events, which encapsulate a single character).</p>
<p>If you use multiple languages or keyboard layouts, Input uses the keyboard layout of the active window rather than the script's (regardless of whether the Input is <a href="#vis">visible</a>).</p>
<p>Although not as flexible, <a href="../Hotstrings.htm">hotstrings</a> are generally easier to use.</p>

<h2 id="comparison">InputHook vs. Input</h2>
<p>InputHook and the <a href="Input.htm">Input</a> function are two different interfaces for the same underlying functionality. The following are mostly equivalent:</p>
<pre>
OutputVar := Input(Options, EndKeys, MatchList)
</pre><pre>
ih := InputHook(Options, EndKeys, MatchList)
ih.Start()
ErrorLevel := ih.Wait()
if (ErrorLevel = "EndKey")
    ErrorLevel .= ":" ih.EndKey
OutputVar := ih.Input
</pre>
<p>The Input function  terminates any previous Input which it started, whereas InputHook allows <a href="#stack">more than one Input</a> at a time.</p>
<p><em>Options</em> is interpreted the same, but the default settings differ:</p>
<ul>
  <li>The Input function limits the length of the input to 16383, while InputHook limits it to 1023. This can be overridden with the <a href="#option-l">L option</a>, and there is no absolute maximum.</li>
  <li>The Input function blocks both text and non-text keystrokes by default, and blocks neither if the <a href="Input.htm#vis">V option</a> is present. By contrast, InputHook blocks only text keystrokes by default (<a href="#VisibleNonText">VisibleNonText</a> defaults to true), so most hotkeys can be used while an Input is in progress.</li>
</ul>
<p>The Input function blocks the <a href="../misc/Threads.htm">thread</a> while it is in progress, whereas InputHook allows the thread to continue, or even exit (which allows any thread that it interrupted to resume). Instead of waiting, the script can register an <a href="#OnEnd">OnEnd</a> function to be called when the Input is terminated.</p>
<p>The Input function returns the user's input only after the Input is terminated, whereas InputHook's <a href="Input.htm">Input</a> property allows it to be retrieved at any time. The script can register an <a href="#OnChar">OnChar</a> function to be called whenever a character is added, instead of continuously checking the Input property.</p>
<p>InputHook gives much more control over individual keys via the <a href="#KeyOpt">KeyOpt</a> method. This includes adding or removing end keys, suppressing or not suppressing specific keys, or ignoring the text produced by specific keys.</p>
<p>Unlike the Input function, InputHook can be used to detect keys which do not produce text, <em>without</em> terminating the Input. This is done by registering an <a href="#OnKeyDown">OnKeyDown</a> function and using <a href="#KeyOpt">KeyOpt</a> or <a href="#NotifyNonText">NotifyNonText</a> to specify which keys are of interest.</p>
<p>If a <em>MatchList</em> item caused the Input to terminate, the <a href="#Match">Match</a> property can be consulted to determine exactly which match (this is more useful when the <a href="#asterisk">* option</a> is present).</p>
<p>Although the script can consult <a href="GetKeyState.htm">GetKeyState</a> after the Input command returns, sometimes it does not accurately reflect which keys were pressed when the Input was terminated. InputHook's <a href="#EndMods">EndMods</a> property reflects the logical state of the modifier keys at the time Input was terminated.</p>
<p>There are some differences relating to backward-compatibility:</p>
<ul>
  <li>The Input function stores end keys <kbd>A</kbd>-<kbd>Z</kbd> in uppercase even though other letters on some keyboard layouts are lowercase. Passing the value to <a href="Send.htm">Send</a> would produce a shifted keystroke instead of a plain one. By contrast, InputHook's <a href="#EndKeys">EndKeys</a> property always returns the normalized name; i.e. whichever character is produced by pressing the key without holding <kbd>Shift</kbd> or other modifiers.</li>
  <li><p>If a key name used in <em>EndKeys</em> corresponds to a VK which is shared between two physical keys (such as <kbd>NumpadUp</kbd> and <kbd>Up</kbd>), the Input function handles the primary key by VK and the secondary key by SC, whereas InputHook handles both by SC. <code>{vkNN}</code> notation can be used to handle the key by VK.</p>
  <p>When the end key is handled by VK, both physical keys can terminate the Input. For example, <code>{NumpadUp}</code> would cause the Input function to be terminated by pressing <kbd>Up</kbd>, but ErrorLevel would contain <code>EndKey:NumpadUp</code> since only the VK is considered.</p>
  <p>When an end key is handled by SC, the Input function always produces names for the known secondary SC of any given VK, and always produces <code>sc<i>NNN</i></code> for any other key (even if it has a name). By contrast, InputHook produces a name if the key has one.</p></li>
</ul>

<h2>Related</h2>
<p><a href="Input.htm">Input</a>, <a href="KeyWait.htm">KeyWait</a>, <a href="../Hotstrings.htm">Hotstrings</a>, <a href="InputBox.htm">InputBox</a>, <a href="_InstallKeybdHook.htm">#InstallKeybdHook</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="IfIn.htm">if var in/contains MatchList</a></p>

<h2>Examples</h2>
<div class="ex" id="ExKeyWaitAny">
<p><a href="#ExKeyWaitAny">#1</a>: Wait for the user to press any single key.</p>
<pre>
MsgBox KeyWaitAny()

<em>; Same again, but don't block the key.</em>
MsgBox KeyWaitAny("V")

KeyWaitAny(Options:="")
{
    ih := InputHook(Options)
    ih.KeyOpt("{All}", "ES")  <em>; End and Suppress</em>
    ih.Start()
    ErrorLevel := ih.Wait()  <em>; Store EndReason in ErrorLevel</em>
    return ih.EndKey  <em>; Return the key name</em>
}
</pre>
</div>
<div class="ex" id="ExKeyWaitCombo">
<p><a href="#ExKeyWaitCombo">#2</a>: Wait for any key in combination with Ctrl/Alt/Shift/Win.</p>
<pre>
MsgBox KeyWaitCombo()

KeyWaitCombo(Options:="")
{
    ih := InputHook(Options)
    ih.KeyOpt("{All}", "ES")  <em>; End and Suppress</em>
    <em>; Exclude the modifiers</em>
    ih.KeyOpt("{LCtrl}{RCtrl}{LAlt}{RAlt}{LShift}{RShift}{LWin}{RWin}", "-ES")
    ih.Start()
    ErrorLevel := ih.Wait()  <em>; Store EndReason in ErrorLevel</em>
    return ih.EndMods . ih.EndKey  <em>; Return a string like &lt;^&lt;+Esc</em>
}
</pre>
</div>
<div class="ex" id="ExSac">
<p><a href="#ExSac">#3</a>: Simple auto-complete: any day of the week.  Pun aside, this is a fully functional example.  Simply run the script and start typing today, press <kbd>Tab</kbd> to complete or press <kbd>Escape</kbd> to exit.</p>
<pre>global WordList := "Monday`nTuesday`nWednesday`nThursday`nFriday`nSaturday`nSunday"

global Suffix := "", SacHook

SacHook := InputHook("V", "{Esc}")
SacHook.OnChar := Func("SacChar")
SacHook.OnKeyDown := Func("SacKeyDown")
SacHook.KeyOpt("{Backspace}", "N")
SacHook.Start()

SacChar(ih, char)  <em>; Called when a character is added to SacHook.Input.</em>
{
    Suffix := ""
    if RegExMatch(ih.Input, "`nm)\w+$", prefix)
        &amp;&amp; RegExMatch(WordList, "`nmi)^" prefix[0] "\K.*", Suffix)
        Suffix := Suffix[0]
    
    CaretGetPos cx, cy
    ToolTip Suffix, cx + 15, cy
    
    <em>; Intercept Tab only while we're showing a Tooltip.</em>
    ih.KeyOpt("{Tab}", Suffix = "" ? "-NS" : "+NS")
}

SacKeyDown(ih, vk, sc)
{
    if (vk = 8) <em>; Backspace</em>
        SacChar(ih, "")
    else if (vk = 9) <em>; Tab</em>
        Send "{Text}" Suffix
}
</pre>
</div>

</body>
</html>