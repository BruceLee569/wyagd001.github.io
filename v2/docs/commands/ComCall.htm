<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>ComCall - 语法 &amp; 使用 | AutoHotkey v2</title>
<meta name="description" content="The ComCall function calls a native COM interface method by index." />
<meta name="ahk:equiv-v1" content="AutoHotkey.htm" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
</head>
<body>

 <h1>ComCall</h1>

 <p>通过索引调用原生 COM 接口方法.</p>

 <pre class="Syntax">Result := <span class="func">ComCall</span>(Index, ComObject <span class="optional">, Type1, Arg1, Type2, Arg2, ReturnType</span>)</pre>
<h2>参数</h2>
<dl>

   <dt>Index</dt>
  <dd>
      <p>类型: <a href="../Concepts.htm#numbers">整数</a></p>
      <p>虚拟函数表中方法的索引(从零开始).</p>
      <p><em>Index</em> 对应于方法在原始接口定义中的位置. Microsoft 文档通常按字母顺序列出方法, 这是不相关的. In order to determine the correct index, locate the original interface definition. This may be in a header file or type library.</p>
      <p>It is important to take into account methods which are inherited from parent interfaces. Since all COM interfaces ultimately derive from <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</a>, the first three methods are always QueryInterface (0), AddRef (1) and Release (2). For example, <em>IShellItem2</em> is an extension of <em>IShellItem</em>, which starts at index 3 and contains 5 methods, so <em>IShellItem2</em>'s first method (GetPropertyStore) is at index 8.</p>
      <p class="note"><strong>提示:</strong> For COM interfaces defined by Microsoft, try searching the Internet or Windows SDK for "<em>IInterfaceName</em><b>Vtbl</b>" - for example, "IUnknownVtbl". Microsoft's own interface definitions are accompanied by this plain-C definition of the interface's virtual function table, which lists all methods explicitly, in the correct order.</p>
      <p>传递无效的索引可能会导致不确定的行为, 包括(但不限于) 程序终止.</p>
  </dd>

   <dt>ComObject</dt>
  <dd>
      <p>类型: <a href="../Concepts.htm#numbers">整数</a>或<a href="../Concepts.htm#objects">对象</a></p>
      <p>目标 COM 对象; 也就是说, 一个 COM 接口指针. 指针值可以直接传递, 也可以封装在带有 <code>Ptr</code> 属性的对象中, 如带有 VT_UNKNOWN 变量类型的 <a href="ComObject.htm">ComObj</a>.</p>
      <p>接口指针用于定位实现接口方法的虚拟函数的地址, 也作为参数传递. This parameter is generally not explicitly present in languages which natively support interfaces, but is shown in the C style "Vtbl" definition.</p>
      <p>Passing an invalid pointer may cause undefined behaviour, including (but not limited to) program termination.</p>
  </dd>

   <dt>Type1, Arg1</dt>
  <dd>
      <p>类型: <a href="../Concepts.htm#strings">字符串</a></p>
      <p>Each of these pairs represents a single parameter to be passed to the method. The number of pairs is unlimited. For <em>Type</em>, see the <a href="DllCall.htm#types">DllCall types table</a>. For <em>Arg</em>, specify the value to be passed to the method.</p>
  </dd>

   <dt>ReturnType</dt>
  <dd>
      <p>类型: <a href="../Concepts.htm#strings">字符串</a></p>
      <p>If omitted, the return type defaults to <a href="DllCall.htm#HRESULT">HRESULT</a>, which is most the common return type for COM interface methods. Any result indicating failure causes an exception to be thrown; therefore, the return type must not be omitted unless the actual return type is HRESULT.</p>
      <p>If the method is of a type that does not return a value (the <code>void</code> return type in C), specify "Int" or any other numeric type without any suffix (except HRESULT), and ignore the return value. As the content of the return value register is arbitrary in such cases, an exception may or may not be thrown if <em>ReturnType</em> is omitted.</p>
      <p>Otherwise, specify one of the argument types from the <a href="DllCall.htm#types">DllCall types table</a>. The <a href="DllCall.htm#asterisk">asterisk suffix</a> is also supported.</p>
      <p id="cdecl">Although ComCall supports the <em>Cdecl</em> keyword as per <a href="DllCall.htm#cdecl">DllCall</a>, it is generally not used by COM interface methods.</p>
  </dd>

 </dl>

 <h2>返回值</h2>
<p>类型: <a href="../Concepts.htm#strings">字符串</a>或<a href="../Concepts.htm#numbers">整数</a></p>
<p>If <em>ReturnType</em> is <a href="DllCall.htm#HRESULT">HRESULT</a> (or omitted) and the method returned an error value (as defined by the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winerror/nf-winerror-failed">FAILED macro</a>), an exception is thrown.</p>
<p>Otherwise, ComCall returns the actual value returned by the method. If the method is of a type that does not return a value (with return type defined in C as <code>void</code>), the result is undefined and should be ignored.</p>

 <h2 id="Remarks">备注</h2>
<p>以下 DllCall 主题也适用于 ComCall:</p>
<ul>
  <li><a href="DllCall.htm#types">Types of Arguments and Return Values</a></li>
  <li><a href="DllCall.htm#error">Errors</a></li>
  <li><a href="DllCall.htm#except">Native Exceptions and A_LastError</a></li>
  <li><a href="DllCall.htm#struct">Structures and Arrays</a></li>
  <li><a href="DllCall.htm#limits">Known Limitations</a></li>
  <li><a href="DllCall.htm#dotnet">.NET Framework</a></li>
</ul>

 <h2>相关</h2>
<p><a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjQuery.htm">ComObjQuery</a>, <a href="ComObject.htm">ComObject</a>, <a href="BufferAlloc.htm">BufferAlloc</a>, <a href="../objects/Buffer.htm">Buffer object</a>, <a href="CallbackCreate.htm">CallbackCreate</a></p>

 <h2>示例</h2>

 <div class="ex" id="ExTaskbar">
<p><a href="#ExTaskbar">#1</a>: Remove the active window from the taskbar for 3 seconds. Compare this to the <a href="DllCall.htm#ExTaskbar">equivalent DllCall example</a>.</p>
<pre><em>/*
  Methods in <a href="http://msdn.microsoft.com/en-us/library/bb774652.aspx">ITaskbarList</a>'s VTable:
    IUnknown:
      0 QueryInterface  -- use <a href="ComObjQuery.htm">ComObjQuery</a> instead
      1 AddRef          -- use <a href="ObjAddRef.htm">ObjAddRef</a> instead
      2 Release         -- use <a href="ObjAddRef.htm">ObjRelease</a> instead
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

 <em>; Create the TaskbarList object and store its address in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

 <em>; Since an IID was specified above, tbl is a pointer (an integer).
; The pointer may be wrapped so that it will be released automatically
; when the script no longer has a reference to the wrapper object.
; This example will still work if the following line is removed:</em>
tbl := ComObject(13, tbl)

activeHwnd := WinExist("A")

ComCall(3, tbl)                     <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774650.aspx">HrInit</a>()</em>
ComCall(5, tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
ComCall(4, tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

if IsObject(tbl)  <em>; Was ComObject(13, tbl) used?</em>
{
    <em>; When finished with the object, simply replace any references with
    ; some other value (or if its a local variable, just return):</em>
    tbl := ""
}
else
{
    <em>; Since the pointer wasn't wrapped, it must be released manually
    ; (although any memory used by the object or the corresponding
    ; library would be reclaimed when the program exits, anyway).</em>
    ObjRelease(tbl)
}
</pre>
</div>

 <div class="ex" id="ExTaskbarClass">
<p><a href="#ExTaskbarClass">#2</a>: Demonstrate some techniques for wrapping COM interfaces. Equivalent to the previous example.</p>
<pre>
tbl := TaskbarList.new()

activeHwnd := WinExist("A")

tbl.DeleteTab(activeHwnd)
Sleep 3000
tbl.AddTab(activeHwnd)

tbl := ""


class TaskbarList {
   static IID := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
   static CLSID := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

    <em>; Called on startup to initialize the class.</em>
   static __new() {
       <em>; Get the base object for all instances of TaskbarList.</em>
       proto := this.Prototype

        <em>; Bound functions can be used to predefine parameters, making
       ; the methods more usable without requiring wrapper functions.
       ; HrInit itself has no parameters, so bind only the index,
       ; and the caller will implicitly provide 'this'.</em>
       proto.DefineMethod "HrInit", Func("ComCall").Bind(3)

        <em>; Leave a parameter blank to let the caller provide a value.
       ; In this case, the blank parameter is 'this' (normally hidden).</em>
       proto.DefineMethod "AddTab", Func("ComCall").Bind(4,, "ptr")

        <em>; An object or Map can be used to reduce repetition.</em>
       for name, args in Map(
           "DeleteTab", [5,,"ptr"],
           "ActivateTab", [6,,"ptr"],
           "SetActiveAlt", [7,,"ptr"]) {
           proto.DefineMethod name, Func("ComCall").Bind(args*)
       }
   }

    <em>; Called by TaskbarList.new() on the new instance.</em>
   __new() {
       this.ptr := ComObjCreate(TaskbarList.CLSID, TaskbarList.IID)
       <em>; If ComObjError(0) was used, this.ptr could be zero.</em>
       if !this.ptr
           throw Exception("COM-related error")
       <em>; Request initialization via ITaskbarList.</em>
       this.HrInit()
   }

    <em>; Release the interface pointer when this object is deleted.</em>
   __delete() =&gt; this.ptr &amp;&amp; ObjRelease(this.ptr)
}
</pre>
</div>

</body>
</html>