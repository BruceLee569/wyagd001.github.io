<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>SetTimer - 语法 &amp; 使用 | AutoHotkey v2</title>
<meta name="description" content="The SetTimer function causes a function to be called automatically and repeatedly at a specified time interval." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
</head>
<body>

<h1>SetTimer</h1>

<p>在指定的时间间隔自动重复调用函数.</p>

<pre class="Syntax"><span class="func">SetTimer</span> <span class="optional">Callback, Period, Priority</span></pre>
<h2 id="Parameters">参数</h2>
<dl>

  <dt id="Callback">Callback</dt>
  <dd>
    <p>类型: <a href="../Concepts.htm#strings">字符串</a>或<a href="../Concepts.htm#objects">对象</a></p>
    <p>要调用的函数. 这可以是函数名称或<a href="../objects/Functor.htm">函数对象</a>. 原义函数名称必须用引号括起来.</p>
    <p>函数对象的<a href="../Concepts.htm#references-to-objects">引用</a>保存在脚本的计时器列表中, 除非删除计时器, 否则不会释放该引用. 对于<a href="#once">只运行一次</a>的计时器, 此操作会自动发生, 但是也可以通过调用 <em>Period(周期)</em> 为 0 的 SetTimer 来完成.</p>
    <p id="OmitCallback">如果省略 <em>Callback</em>, 如果有的话, SetTimer 将在启动当前线程的定时器上运行. 例如, <code>SetTimer , 0</code> 可以在一个定时器函数中用于标记要删除的定时器, 而 <code>SetTimer , 1000</code> 将更新当前定时器的 <em>Period</em>.</p>
    <p class="warning"><strong>注意:</strong> 传递空变量或返回空值的表达式被看做一个错误. 这个参数必须为非空的值或完全忽略.</p>
  </dd>

  <dt>Period</dt>
  <dd>
    <p>类型: <a href="../Concepts.htm#numbers">整数</a></p>
    <p>参数的绝对值被用作在执行计时器之前必须经过的<a href="#Precision">大约</a>毫秒数. 定时器将被自动<a href="#reset">重置</a>. 可以设置为自动重复或只运行一次:</p>
    <ul>
      <li>如果 <em>Period</em> 大于 0, 定时器将自动重复, 直到脚本明确禁用.</li>
      <li id="once">如果 <em>Period</em> 小于 0, 定时器将只运行一次. 例如, 指定 -100 将在 100 ms 后调用 <em>回调</em>, 然后删除定时器, 就像使用 <code>SetTimer <i>Callback</i>, 0</code> 一样.</li>
      <li>如果 <em>Period</em> 为 0, 定时器被标记为删除. 如果由这个定时器启动的线程还在运行, 那么在线程结束后, 定时器就会被删除(除非它被重新启用); 否则, 它会被立即删除. 在任何情况下, 定时器之前的 <em>Period</em> 和 <em>Priority</em> 都不会被保留.</li>
    </ul>
    <p><em>Period</em> 的绝对值不能大于 4294967295 ms(49.7 天).</p>
    <p><strong>默认值</strong>: 如果此参数为空并且:<br>
    1) 计时器不存在: 则使用 250 的周期进行创建.<br>
    2) 计时器已经存在: 则以原来的 <em>period</em> 进行<a href="#reset">重置</a>, 除非指定了 <em>Priority(优先级)</em>.</p>
  </dd>

  <dt>Priority</dt>
  <dd>
    <p>类型: <a href="../Concepts.htm#numbers">整数</a></p>
    <p>这个可选参数是一个介于 -2147483648 和 2147483647 之间的整数(或为<a href="../Variables.htm#Expressions">表达式</a>) 来表示计时器的优先级. 如果省略, 则使用 0. 有关详情, 请参阅<a href="../misc/Threads.htm">线程</a>.</p>
    <p>要改变现有计时器的优先级而不以任何其他方式影响它, 请省略 <em>Period</em>.</p>
  </dd>

</dl>

<h2 id="Remarks">备注</h2>
<p>计时器很有用, 因为它们是异步运行的, 这意味着它们会以指定的频率(间隔) 运行, 即使脚本正等待窗口, 显示对话框或忙于其他任务的时候. 它们的许多应用实例包括了当用户空闲时(如 <a href="../Variables.htm#TimeIdle">A_TimeIdle</a> 反映的那样) 执行一些动作或在不需要的窗口出现时关闭它们.</p>
<p>尽管计时器给人一种脚本同时执行多个任务的错觉, 实际并非如此. 相反地, 定时子程序只是被当作其他线程来处理: 它们可以中断另一个线程或被另一个线程中断, 例如 <a href="../Hotkeys.htm">热键子程序</a>. 有关详情, 请参阅<a href="../misc/Threads.htm">线程</a>.</p>
<p>每当创建或重新启用计时器或用新的 <em>period</em> 更新计时器时, its function will not be called right away; its time <em>period</em> must expire first. If you wish the timer's first execution to be immediate, call the timer's function directly (however, this will not start a new thread like the timer itself does; so settings such as <a href="SendMode.htm">SendMode</a> will not start off at their defaults).</p>
<p id="reset"><strong>重置</strong>: If SetTimer is used on an existing timer, the timer is reset (unless <em>Priority</em> is specified and <em>Period</em> is omitted); in other words, the entirety of its period must elapse before its function will be called again.</p>
<p id="Precision"><strong>计时器精度</strong>: Due to the granularity of the OS's time-keeping system, <em>Period</em> is typically rounded up to the nearest multiple of 10 or 15.6 milliseconds (depending on the type of hardware and drivers installed). A shorter delay may be achieved via Loop+Sleep as demonstrated at <a href="Sleep.htm#ExShorterSleep">DllCall+timeBeginPeriod+Sleep</a>.</p>
<p id="Reliability"><strong>可靠性</strong>: A timer might not be able to run at the expected time under the following conditions:</p>
<ol>
  <li>Other applications are putting a heavy load on the CPU.</li>
  <li>The timer's function is still running when the timer period expires again.</li>
  <li>There are too many other competing timers.</li>
  <li>The timer has been interrupted by another <a href="../misc/Threads.htm">thread</a>, namely another timed function, <a href="../Hotkeys.htm">hotkey subroutine</a>, or <a href="../objects/Menu.htm">custom menu item</a> (this can be avoided via <a href="Critical.htm">Critical</a>). If this happens and the interrupting thread takes a long time to finish, the interrupted timer will be effectively disabled for the duration. However, any other timers will continue to run by interrupting the <a href="../misc/Threads.htm">thread</a> that interrupted the first timer.</li>
  <li>The script is uninterruptible as a result of <a href="Critical.htm">Critical</a> or <a href="Thread.htm">Thread "Interrupt/Priority"</a>. During such times, timers will not run. Later, when the script becomes interruptible again, any overdue timer will run once as soon as possible and then resume its normal schedule.</li>
</ol>
<p>Although timers will operate when the script is <a href="Suspend.htm">suspended</a>, they will not run if the <a href="../misc/Threads.htm">current thread</a> has <a href="Thread.htm">Thread "NoTimers"</a> in effect or whenever any thread is <a href="Pause.htm">paused</a>. In addition, they do not operate when the user is navigating through one of the script's menus (such as the tray icon menu or a menu bar).</p>
<p>Because timers operate by temporarily interrupting the script's current activity, their functions should be kept short (so that they finish  quickly) whenever a long interruption would be undesirable.</p>
<p id="otherremarks"><strong>Other remarks</strong>: Timers that stay in effect for the duration of a script should usually be created in the <a href="../Scripts.htm#auto">auto-execute section</a>. By contrast, a temporary timer might often be disabled by its own function (see examples at the bottom of this page).</p>
<p>Whenever a function is called by a timer, it starts off fresh with the default values for settings such as <a href="SendMode.htm">SendMode</a>. These defaults can be changed in the <a href="../Scripts.htm#auto">auto-execute section</a>.</p>
<p>If <a href="../Hotkeys.htm">hotkey</a> response time is crucial (such as in games) and the script contains any timers whose functions take longer than about 5 ms to execute, use the following function to avoid any chance of a 15 ms delay. Such a delay would otherwise happen if a hotkey is pressed at the exact moment a timer thread is in its period of uninterruptibility:</p>
<pre><a href="Thread.htm">Thread</a> "interrupt", 0  <em>; Make all threads always-interruptible.</em></pre>
<p>If a timer is disabled while its function is currently running, that function will continue until it completes.</p>
<p>The <a href="KeyHistory.htm">KeyHistory</a> feature shows how many timers exist and how many are currently enabled.</p>

<h2 id="Related">相关</h2>
<p><a href="../misc/Threads.htm">Threads</a>, <a href="Thread.htm">Thread (function)</a>, <a href="Critical.htm">Critical</a>, <a href="../objects/Functor.htm">Function Objects</a></p>

<h2 id="Examples">示例</h2>
<div class="ex" id="ExampleClose">
<p><a href="#ExampleClose">#1</a>: 当不想要的窗口出现时关闭它们:</p>
<pre>SetTimer "CloseMailWarnings", 250

CloseMailWarnings()
{
    WinClose "Microsoft Outlook", "A timeout occured while communicating"
    WinClose "Microsoft Outlook", "A connection to the server could not be established"
}</pre>
</div>

<div class="ex" id="ExampleWait">
<p><a href="#ExampleWait">#2</a>: 等待特定的窗口出现, 然后通知用户:</p>
<pre>SetTimer "Alert1", 500

Alert1()
{
    if !WinExist("Video Conversion", "Process Complete")
        return
    <em>; Otherwise:</em>
    SetTimer, 0  <em>; i.e. the timer turns itself off here.</em>
    MsgBox "The video conversion is finished."
}</pre>
</div>

<div class="ex" id="ExampleCount">
<p><a href="#ExampleCount">#3</a>: 检测热键的单次, 两次和三次按下. 这样允许热键根据您按下次数的多少执行不同的操作:</p>
<pre>#c::
KeyWinC()  <em>; This is a <a href="../Hotkeys.htm#Function">function hotkey</a>.</em>
{
    static winc_presses := 0
    if winc_presses &gt; 0 <em>; SetTimer already started, so we log the keypress instead.</em>
    {
        winc_presses += 1
        return
    }
    <em>; Otherwise, this is the first press of a new series. Set count to 1 and start
    ; the timer:</em>
    winc_presses := 1
    SetTimer "After400", -400 <em>; Wait for more presses within a 400 millisecond window.</em>

    After400()  <em>; This is a <a href="../Functions.htm#nested">nested function</a>.</em>
    {
        if winc_presses = 1 <em>; The key was pressed once.</em>
        {
            Run "m:\"  <em>; Open a folder.</em>
        }
        else if winc_presses = 2 <em>; The key was pressed twice.</em>
        {
            Run "m:\multimedia"  <em>; Open a different folder.</em>
        }
        else if winc_presses &gt; 2
        {
            MsgBox "Three or more clicks detected."
        }
        <em>; Regardless of which action above was triggered, reset the count to
        ; prepare for the next series of presses:</em>
        winc_presses := 0
    }
}
</pre>
</div>

<div class="ex" id="ExampleClass">
<p><a href="#ExampleClass">#4</a>: 使用 <a href="../Objects.htm#Custom_Classes_method">method</a> 作为计时器函数.</p>
<pre>counter := SecondCounter.new()
counter.Start
Sleep 5000
counter.Stop
Sleep 2000

<em>; An example class for counting the seconds...</em>
class SecondCounter {
    __New() {
        this.interval := 1000
        this.count := 0
        <em>; Tick() has an implicit parameter "this" which is a reference to
        ; the object, so we need to create a function which encapsulates
        ; "this" and the method to call:</em>
        this.timer := ObjBindMethod(this, "Tick")
    }
    Start() {
        SetTimer this.timer, this.interval
        ToolTip "Counter started"
    }
    Stop() {
        <em>; To turn off the timer, we must pass the same object as before:</em>
        SetTimer this.timer, 0
        ToolTip "Counter stopped at " this.count
    }
    <em>; In this example, the timer calls this method:</em>
    Tick() {
        ToolTip ++this.count
    }
}</pre>
<p>示例 #4 的备注:</p>
<ul>
  <li>We can also use <code>this.timer := this.GetMethod("Tick").<a href="../objects/Func.htm#Bind">Bind</a>(this)</code>.  When <code>this.timer</code> is called, it will effectively invoke <code><i>tick_function</i>.<a href="../objects/Func.htm#Call">Call</a>(this)</code>, where <i>tick_function</i> is the function object which implements that method. By contrast, <a href="ObjBindMethod.htm">ObjBindMethod</a> produces an object which invokes <code>this.Tick()</code>.</li>
  <li>If we rename <em>Tick</em> to <em>Call</em>, we can just use <code>this</code> directly instead of <code>this.timer</code>.  However, ObjBindMethod is useful when the object has multiple methods which should be called by different event sources, such as hotkeys, menu items, GUI controls, etc.</li>
  <li>If the timer is being modified or deleted from within a function/method called by the timer, it may be easier to <a href="#OmitCallback">omit the <em>Callback</em> parameter</a>. In some cases this avoids the need to retain the original object which was passed to SetTimer.</li>
</ul>
</div>

</body>
</html>