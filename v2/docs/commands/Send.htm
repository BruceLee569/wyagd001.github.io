<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>Send - 语法 &amp; 使用 | AutoHotkey v2</title>
<meta name="description" content="The Send, SendText, SendInput, SendPlay and SendEvent functions send simulated keystrokes and mouse clicks to the active window." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
</head>
<body>

<h1>Send, SendText, SendInput, SendPlay, SendEvent</h1>

<p>发送模拟键击和鼠标点击到<a href="WinActivate.htm">活动</a>窗口.</p>

<pre class="Syntax"><span class="func">Send</span> Keys
<span class="func">SendText</span> Keys
<span class="func">SendInput</span> Keys
<span class="func">SendPlay</span> Keys
<span class="func">SendEvent</span> Keys</pre>

<h2 id="Parameters">参数</h2>
<dl>

  <dt>Keys</dt>
  <dd>
    <p>类型: <a href="../Concepts.htm#strings">字符串</a></p>
    <p>要发送的按键序列.</p>
    <p>默认情况下(也就是说, 如果不使用<a href="#Raw">原始模式</a>或<a href="#Text">文本模式</a>), 字符 <code>^+!#{}</code>  具有特殊含义. 字符 <code>^+!#</code> 分别代表修饰符键 <kbd>Ctrl</kbd>, <kbd>Shift</kbd>, <kbd>Alt</kbd> 和 <kbd>Win</kbd>. 他们仅影响紧跟着的下一个键. 若要发送修饰符本身对应的键, 将按键名称括在大括号中. 若要按下(按住) 或松开按键, 下面所示的单词 "down" 或 "up" 跟在按键名称的后面.</p>
    <style>
      #modifierkeys td:not(:last-child) {
        white-space: nowrap;
        text-align: center
      }
    </style>
    <table id="modifierkeys" class="info">
      <tr>
        <th>符号</th>
        <th>按键</th>
        <th>按下</th>
        <th>松开</th>
        <th>示例</th>
      </tr>
      <tr>
        <td>^</td>
        <td>{Ctrl}</td>
        <td>{Ctrl down}</td>
        <td>{Ctrl up}</td>
        <td><code>Send "^{Home}"</code> 按下 <kbd>Control</kbd>+<kbd>Home</kbd></td>
      </tr>
      <tr>
        <td>+</td>
        <td>{Shift}</td>
        <td>{Shift down}</td>
        <td>{Shift up}</td>
        <td><code>Send "+abC"</code> 发送文本 "AbC"<br>
          <code>Send "!+a"</code> 按下 <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd></td>
      </tr>
      <tr>
        <td>!</td>
        <td>{Alt}</td>
        <td>{Alt down}</td>
        <td>{Alt up}</td>
        <td><code>Send "!a"</code> 按下 <kbd>Alt</kbd>+<kbd>A</kbd></td>
      </tr>
      <tr>
        <td>#</td>
        <td>{LWin}<br>{RWin}</td>
        <td>{LWin down}<br>{RWin down}</td>
        <td>{LWin up}<br>{RWin up}</td>
        <td><code>Send "#e"</code>  按住 <kbd>Win</kbd> 键时按下字母 <kbd>E</kbd> 键</td>
      </tr>
    </table>
    <p class="note"><strong>注意</strong>: 由于大写字母是通过发送 <kbd>Shift</kbd> 键产生的, 因此在某些程序中 <code>A</code> 和 <code>a</code> 会产生不同的效果. 例如, <code>!A</code> 按下 <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd>, 而 <code>!a</code> 按下 <kbd>Alt</kbd>+<kbd>A</kbd>. 如果不确定, 请使用小写字母.</p>
    <p>字符 <code>{}</code> 用于括起<a href="#keynames">键名和其他选项</a>, 并发送特殊的原义字符. 例如, <code>{Tab}</code> 是 <kbd>Tab</kbd> 键, 而 <code>{!}</code> 是原义的感叹号.</p>
    <p>将一个纯 ASCII 字母(a-z 或 A-Z) 括在大括号中强制它作为相应的虚拟键码发送, 即使该字符在当前键盘布局上不存在. 换句话说, <code>Send a</code> 产生字母 "a", 而 <code>Send {a}</code> 根据键盘布局, 可能产生也可能不产生 "a". 有关详情, 请参阅<a href="#AZ">下面的注释</a>.</p>
  </dd>

</dl>

<h2 id="Send_variants">Send 的变体</h2>
<p><strong>Send:</strong> 默认情况下, Send 等同于 SendInput; 但是可以通过 <a href="SendMode.htm">SendMode</a> 使其等同于 SendEvent 或 SendPlay.</p>
<p><strong>SendText:</strong> 类似于 Send, 除了 <em>Keys</em> 中的所有字符都按原义解释. 有关详情, 请参阅<a href="#Text">文本模式</a>.</p>
<p><strong id="SendInput">SendInput</strong> 和 <strong id="SendPlay">SendPlay</strong>: SendInput 和 SendPlay 使用与 SendEvent 相同的语法, 但通常更快更可靠. 此外, 它们在发送过程中缓冲任何物理键盘或鼠标活动, 这可以防止用户的击键与发送的击键穿插在一起. 通过 <a href="SendMode.htm">SendMode</a> 可以使 Send 等同于 SendInput 或 SendPlay. 有关每种模式的更多信息, 请参阅下面的 <a href="#SendInputDetail">SendInput</a> 和 <a href="#SendPlayDetail">SendPlay</a>.</p>
<p id="SendEvent"><strong>SendEvent</strong>: SendEvent 使用 Windows keybd_event 函数发送键击(有关详情, 请搜索 MSDN). 发送击键的速率由 <a href="SetKeyDelay.htm">SetKeyDelay</a> 决定. 通过 <a href="SendMode.htm">SendMode</a> 可以使 Send 等同于 SendEvent 或 SendPlay.</p>

<h2 id="Special_modes">特殊模式</h2>
<p>以下模式影响 <em>Keys</em> 中字符的解释, 或键发送命令的行为, 例如 Send, SendInput, SendPlay, SendEvent 和 <a href="ControlSend.htm">ControlSend</a>. 这些模式必须在 <em>Keys</em> 中指定 <code>{x}</code>, 其中 x 可以是 Raw, Text 或 Blind. 例如, <code>{Raw}</code>.</p>

<h3 id="Raw">原始模式</h3>
<p id="SendRaw">可以使用 <code>{Raw}</code> 启用原始模式, 这会导致所有后续字符, 包括特殊字符 <code>^+!#{}</code>, 都按原义进行解释, 如 <code>{Enter}</code> 不会转换为 <kbd>Enter</kbd> 键击, <code>^c</code> 不会转换为 <kbd>Control</kbd>+<kbd>C</kbd>, 等等. 例如, <code>Send "{Raw}{Tab}"</code> 发送 <code>{Tab}</code>, 而不是 <kbd>Tab</kbd> 键击.</p>
	<p>原始模式不影响<a href="../misc/EscapeChar.htm">转义序列</a>和<a href="../Variables.htm#Expressions">表达式</a>的解释. 例如, <code>Send "{Raw}``100`%"</code> 发送字符 <code class="no-highlight">`100%</code>.</p>

<h3 id="Text">文本模式</h3>
<p id="SendText">可以使用 <code>{Text}</code> 或 <a href="ControlSend.htm">ControlSendText</a>来启用文本模式, 与原始模式类似, 不同之处在于不会尝试将字符(<code>`r</code>, <code>`n</code>, <code>`t</code> 和 <code>`b</code> 除外) 转换为键码; 作为代替, <a href="#fallback">后备方法</a>适用于所有剩余的字符. 对于 SendEvent, SendInput 和 <a href="ControlSend.htm">ControlSend</a>, 这提高了可靠性, 因为字符对正确的修饰符状态的依赖性要小得多. 文本模式可以与盲从模式结合使用, 以避免释放任何修饰键: <code>Send "{Blind}{Text}your text"</code>. 但是, 一些应用程序会要求修饰键被释放.</p>
<p><code>`n</code>, <code>`r</code> 和 <code>`r`n</code> 都被转换为一次单独的 <kbd>Enter</kbd> 键击, 不像普通模式和原始模式, 转换 <code>`r`n</code> 为两次 <kbd>Enter</kbd> 键击. <code>`t</code> 转换为 <kbd>Tab</kbd>, 而 <code>`b</code> 转换为 <kbd>Backspace</kbd>, 但所有其他字符都是不经转换直接发送的.</p>
<p>与盲从模式类似, 文本模式忽略 <a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a>(也就是说, 不会改变 <kbd>CapsLock</kbd> 的状态), 并且不<a href="../Hotkeys.htm#win-l">等待 <kbd>Win</kbd> 键被释放</a>. 这是因为文本模式通常不依赖于 <kbd>CapsLock</kbd> 的状态, 并且不能触发系统 <kbd>Win</kbd>+<kbd>L</kbd> 热键. 但是, 这仅适用于当 <em>Keys</em> 以 <code>{Text}</code> 或 <code>{Blind}{Text}</code> 开头时.</p>

<h3 id="Blind">盲从模式</h3>
<p id="blind">可以使用 <code>{Blind}</code> 启用盲从模式, 该模式通过禁用通常自动执行的许多操作来使脚本按预期运行, 从而赋予脚本更多控制权. 要启用盲从模式, <code>{Blind}</code> 必须是字符串中的第一个项目. 它具有以下效果:</p>
<ul>
  <li>如果在发送开始时 <kbd>Alt</kbd>/<kbd>Control</kbd>/<kbd>Shift</kbd>/<kbd>Win</kbd> 为按下的状态, 则盲从模式避免释放这些按键, 除非该修饰键被<a href="#blind-exclude">排除</a>了. 例如, 热键 <code>+s::Send "{Blind}abc"</code> 将发送 ABC 而不是 abc, 因为用户按住了 <kbd>Shift</kbd>.</li>
  <li>修饰键有不同的恢复方式, 以允许 Send 能关闭热键的修饰键, 即使用户在物理上仍然是按下的. 例如, 如果用户仍然物理按住 <kbd>Ctrl</kbd>, 则 <code>^space::Send "{Ctrl up}"</code> 自动推送 <kbd>Ctrl</kbd> 按下, 而 <code>^space::Send "{Blind}{Ctrl up}"</code> 允许 <kbd>Ctrl</kbd> 逻辑松开, 即使它物理上是按下的.</li>
  <li><a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a> 会被忽略; 也就是说, 不会改变 <kbd>CapsLock</kbd> 的状态.</li>
  <li><a href="_MenuMaskKey.htm">菜单掩饰</a>是禁用的. 也就是说, Send 忽略额外的击键, 这些键原本会被发送, 以防止: 1) 在按下 <kbd>Win</kbd>(LWin/RWin) 键时, 出现开始菜单; 2)在按下 <kbd>Alt</kbd> 键时, 菜单栏的激活. 然而, 盲从模式不会阻止在钩子热键激活后由键盘钩子进行的掩饰.</li>
  <li>即使文本包含一个 <kbd>L</kbd> 按键, Send 也不会等待 <kbd>Win</kbd> 按键被释放. 一般情况下会等待, 以防止 Send 触发系统 "锁定工作站" 的热键(<kbd>Win</kbd>+<kbd>L</kbd>). 有关详情, 请参阅<a href="../Hotkeys.htm#win-l">热键</a>.</li>
</ul>
<p id="blind-exclude">单词 "Blind" 后面可以用一个或多个修饰符号(<code>!#^+</code>) 以便在需要时自动释放这些修饰符. 例如, <code>*^a::Send "{Blind^}b"</code> 在按下 <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd> 时, 将发送 <kbd>Shift</kbd>+<kbd>B</kbd> 而不是 <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>B</kbd>. <code>{Blind!#^+}</code> 可以在需要的时候释放所有的修饰符, 但是会启用盲从模式的其他效果.</p>
<p>在<a href="../misc/Remap.htm">重映射按键</a>时, 盲从模式可以在其内部使用. 例如, 重映射 <code>a::b</code> 会发生这样的情况: 1) 输入 "a" 时会映射为 "b"; 2) 输入大写字母 "A" 时映射为大写字母 "B"; 并且 3) 按下 <kbd>Control</kbd>+<kbd>A</kbd> 时映射为按下 <kbd>Control</kbd>+<kbd>B</kbd>. 如果任何修饰符指定为源按键(包括 <kbd>Shift</kbd> 如果源按键是大写字母), 则如上所述, 这些修饰符被排除在外. 例如 <code>^a::b</code> 产生的是正常的 <kbd>B</kbd>, 而不是 <kbd>Control</kbd>+<kbd>B</kbd>.</p>
<p>SendText 或 <a href="ControlSend.htm">ControlSendText</a> 不支持 <code>{Blind}</code>; 请使用 <code>{Blind}{Text}</code> 代替.</p>
<p><a href="#SendPlayDetail">SendPlay</a> 不完全支持盲从模式, 尤其是在处理修饰键时(<kbd>Control</kbd>, <kbd>Alt</kbd>, <kbd>Shift</kbd> 和 <kbd>Win</kbd>).</p>

<h2 id="keynames">Key 名称</h2>
<p>下表中列出了可以发送的特殊按键(每个按键名称必须用大括号括起来):</p>
<table class="info">
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{F1} - {F24}</td>
    <td>功能键. 例如: {F12} 表示 <kbd>F12</kbd>.</td>
  </tr>
  <tr>
    <td>{!}</td>
    <td>!</td>
  </tr>
  <tr>
    <td>{#}</td>
    <td>#</td>
  </tr>
  <tr>
    <td>{+}</td>
    <td>+</td>
  </tr>
  <tr>
    <td>{^}</td>
    <td>^</td>
  </tr>
  <tr>
    <td>{{}</td>
    <td>{</td>
  </tr>
  <tr>
    <td>{}}</td>
    <td>}</td>
  </tr>
  <tr>
    <td>{Enter}</td>
    <td>主键盘上的 <kbd>Enter</kbd> 键</td>
  </tr>
  <tr>
    <td>{Escape} 或 {Esc}</td>
    <td><kbd>Escape</kbd></td>
  </tr>
  <tr>
    <td>{Space}</td>
    <td><kbd>Space</kbd>(这只适用于出现在要发送的字符串的开头或结尾的空格 -- 而在中间的空格是原义的)</td>
  </tr>
  <tr>
    <td>{Tab}</td>
    <td><kbd>Tab</kbd></td>
  </tr>
  <tr>
    <td>{Backspace} 或 {BS}</td>
    <td><kbd>Backspace</kbd></td>
  </tr>
  <tr>
    <td>{Delete} 或 {Del}</td>
    <td><kbd>Delete</kbd></td>
  </tr>
  <tr>
    <td>{Insert} 或 {Ins}</td>
    <td><kbd>Insert</kbd></td>
  </tr>
  <tr>
    <td>{Up}</td>
    <td><kbd>&uarr;</kbd>(主键盘上的向上键)</td>
  </tr>
  <tr>
    <td>{Down}</td>
    <td><kbd>&darr;</kbd>(主键盘上的向下键)</td>
  </tr>
  <tr>
    <td>{Left}</td>
    <td><kbd>&larr;</kbd>(主键盘上的向左键)</td>
  </tr>
  <tr>
    <td>{Right}</td>
    <td><kbd>&rarr;</kbd>(主键盘上的向右键)</td>
  </tr>
  <tr>
    <td>{Home}</td>
    <td><kbd>Home</kbd>(主键盘)</td>
  </tr>
  <tr>
    <td>{End}</td>
    <td><kbd>End</kbd>(主键盘)</td>
  </tr>
  <tr>
    <td>{PgUp}</td>
    <td><kbd>PageUp</kbd>(主键盘)</td>
  </tr>
  <tr>
    <td>{PgDn}</td>
    <td><kbd>PageDown</kbd>(主键盘)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{CapsLock}</td>
    <td><kbd>CapsLock</kbd>(使用 <a href="SetNumScrollCapsLockState.htm">SetCapsLockState</a> 更可靠). 发送 {CapsLock} 之前可能要求 <code><a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a> "Off"</code>.</td>
  </tr>
  <tr>
    <td>{ScrollLock}</td>
    <td><kbd>ScrollLock</kbd>(另请参阅: <a href="SetNumScrollCapsLockState.htm">SetScrollLockState</a>)</td>
  </tr>
  <tr>
    <td>{NumLock}</td>
    <td><kbd>NumLock</kbd>(另请参阅: <a href="SetNumScrollCapsLockState.htm">SetNumLockState</a>)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Control} 或 {Ctrl}</td>
    <td><kbd>Control</kbd> 键(技术信息: 发送中性键的虚拟键码而不是左边键的扫描码)</td>
  </tr>
  <tr>
    <td>{LControl} 或 {LCtrl}</td>
    <td>左 <kbd>Control</kbd> 键(技术信息: 发送左边键的虚拟键码而不是中性键)</td>
  </tr>
  <tr>
    <td>{RControl} 或 {RCtrl}</td>
    <td>右 <kbd>Control</kbd> 键</td>
  </tr>
  <tr>
    <td>{Control down} 或 {Ctrl down}</td>
    <td>按住 <kbd>Control</kbd> 键直到发送 {Ctrl up}. 要按住左边或右边的键, 请使用 {RCtrl down} 和 {RCtrl up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Alt}</td>
    <td><kbd>Alt</kbd> 键(技术信息: 发送中性键的虚拟键码而不是左边键的扫描码)</td>
  </tr>
  <tr>
    <td>{LAlt}</td>
    <td>左 <kbd>Alt</kbd> 键(技术信息: 发送左边键的虚拟键码而不是中性键)</td>
  </tr>
  <tr>
    <td>{RAlt}</td>
    <td>右 <kbd>Alt</kbd> 键(或 <kbd>AltGr</kbd>, 取决于键盘布局)</td>
  </tr>
  <tr>
    <td>{Alt down}</td>
    <td>按住 <kbd>Alt</kbd> 键直到发送 {Alt up}. 要按住左边或右边的键, 请使用 {RAlt down} 或 {RAlt up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Shift}</td>
    <td><kbd>Shift</kbd>(技术信息: 发送中性键的虚拟键码而不是左边键的扫描码)</td>
  </tr>
  <tr>
    <td>{LShift}</td>
    <td>左 <kbd>Shift</kbd> 键(技术信息: 发送左边键的虚拟键码而不是中性键)</td>
  </tr>
  <tr>
    <td>{RShift}</td>
    <td>右 <kbd>Shift</kbd> 键</td>
  </tr>
  <tr>
    <td>{Shift down}</td>
    <td>按住 <kbd>Shift</kbd> 键直到发送 {Shift up}. 要按住左边或右边的键, 请使用 {RShift down} 或 {RShift up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{LWin}</td>
    <td>左 <kbd>Win</kbd> 键</td>
  </tr>
  <tr>
    <td>{RWin}</td>
    <td>右 <kbd>Win</kbd> 键</td>
  </tr>
  <tr>
    <td>{LWin down}</td>
    <td>按住左 <kbd>Win</kbd> 键直到发送 {LWin up}</td>
  </tr>
  <tr>
    <td>{RWin down}</td>
    <td>按住右 <kbd>Win</kbd> 键直到发送 {RWin up}</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{AppsKey}</td>
    <td><kbd>Menu</kbd> 键(调用右键点击或上下文菜单)</td>
  </tr>
  <tr>
    <td>{Sleep}</td>
    <td><kbd>Sleep</kbd> 键.</td>
  </tr>
  <tr id="asc">
    <td>{ASC nnnnn}</td>
    <td><p>发送 <kbd>Alt</kbd>+nnnnn 小键盘上的按键组合, 可以用来生成键盘上不存在的特殊字符. 要生成 ASCII 字符, 请指定一个介于 1 和 255 之间的数字. 要生成 ANSI 字符(在大多数语言中的标准), 请指定一个介于 128 和 255 之间的数字, 但需要在数字前加上一个前导零, 例如 {Asc 0133}..</p>
    <p>要生成 Unicode 字符, 请指定一个介于 256 和 65535 之间的数字(不带前导零). 但是, 有些应用程序不支持这种方法. 对于替代方法, 请参阅下面的部分.</p></td>
  </tr>
  <tr id="Unicode">
    <td>{U+nnnn}</td>
    <td><p id="sendu">发送 Unicode 字符, 其中 <em>nnnn</em> 为字符的不包括 0x 前缀的十六进制值. 通常不需要这么做, 因为 Send 和 ControlSend 自动支持 Unicode 文本.</p>
    <p><a href="http://msdn.microsoft.com/en-us/library/ms646310.aspx">SendInput()</a> 或 <a href="http://msdn.microsoft.com/en-us/library/ms646276.aspx">WM_CHAR</a> is used to send the character and the current Send mode has no effect. Characters sent this way usually do not trigger shortcut keys or hotkeys.</p></td>
  </tr>
  <tr id="vk">
    <td><p>{vkXX}<br>
      {scYYY}<br>
    {vkXXscYYY}</p></td>
    <td><p>Sends a keystroke that has virtual key XX and scan code YYY. 例如: <code>Send "{vkFFsc159}"</code>. If the sc or vk portion is omitted, the most appropriate value is sent in its place.</p>
      <p>The values for XX and YYY are hexadecimal and can usually be determined from the main window's <a href="KeyHistory.htm">View-&gt;Key history</a> menu item. See also: <a href="../KeyList.htm#SpecialKeys">Special Keys</a></p>
      <p class="warning"><strong>Warning:</strong> Combining vk and sc in this manner is valid only with Send.</p></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Numpad0} - {Numpad9}</td>
    <td>Numpad digit keys (as seen when <kbd>NumLock</kbd> is ON). 例如: {Numpad5} is <kbd>5</kbd>.</td>
  </tr>
  <tr>
    <td>{NumpadDot}</td>
    <td><kbd>.</kbd> (numpad period) (as seen when <kbd>NumLock</kbd> is ON).</td>
  </tr>
  <tr>
    <td>{NumpadEnter}</td>
    <td><kbd>Enter</kbd> key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadMult}</td>
    <td><kbd>*</kbd> (numpad multiplication)</td>
  </tr>
  <tr>
    <td>{NumpadDiv}</td>
    <td><kbd>/</kbd> (numpad division)</td>
  </tr>
  <tr>
    <td>{NumpadAdd}</td>
    <td><kbd>+</kbd> (numpad addition)</td>
  </tr>
  <tr>
    <td>{NumpadSub}</td>
    <td><kbd>-</kbd> (numpad subtraction)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{NumpadDel}</td>
    <td><kbd>Delete</kbd> key on keypad (this key and the following Numpad keys are used when <kbd>NumLock</kbd> is OFF)</td>
  </tr>
  <tr>
    <td>{NumpadIns}</td>
    <td><kbd>Insert</kbd> key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadClear}</td>
    <td>Clear key on keypad (usually the '5' key when <kbd>NumLock</kbd> is OFF).</td>
  </tr>
  <tr>
    <td>{NumpadUp}</td>
    <td><kbd>&uarr;</kbd> (up arrow) key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadDown}</td>
    <td><kbd>&darr;</kbd> (down arrow) key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadLeft}</td>
    <td><kbd>&larr;</kbd> (left arrow) on keypad</td>
  </tr>
  <tr>
    <td>{NumpadRight}</td>
    <td><kbd>&rarr;</kbd> (right arrow) key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadHome}</td>
    <td><kbd>Home</kbd> key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadEnd}</td>
    <td><kbd>End</kbd> key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadPgUp}</td>
    <td><kbd>PageUp</kbd> key on keypad</td>
  </tr>
  <tr>
    <td>{NumpadPgDn}</td>
    <td><kbd>PageDown</kbd> key on keypad</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Browser_Back}</td>
    <td>Select the browser &quot;back&quot; button</td>
  </tr>
  <tr>
    <td>{Browser_Forward}</td>
    <td>Select the browser &quot;forward&quot; button</td>
  </tr>
  <tr>
    <td>{Browser_Refresh}</td>
    <td>Select the browser &quot;refresh&quot; button</td>
  </tr>
  <tr>
    <td>{Browser_Stop}</td>
    <td>Select the browser &quot;stop&quot; button</td>
  </tr>
  <tr>
    <td>{Browser_Search}</td>
    <td>Select the browser &quot;search&quot; button</td>
  </tr>
  <tr>
    <td>{Browser_Favorites}</td>
    <td>Select the browser &quot;favorites&quot; button</td>
  </tr>
  <tr>
    <td>{Browser_Home}</td>
    <td>Launch the browser and go to the home page</td>
  </tr>
  <tr>
    <td>{Volume_Mute}</td>
    <td>Mute/unmute the master volume. Usually equivalent to <code><a href="SoundSetMute.htm">SoundSetMute</a> -1</code>.</td>
  </tr>
  <tr>
    <td>{Volume_Down}</td>
    <td>Reduce the master volume. Usually equivalent to <code><a href="SoundSetVolume.htm">SoundSetVolume</a> -5</code>.</td>
  </tr>
  <tr>
    <td>{Volume_Up}</td>
    <td>Increase the master volume. Usually equivalent to <code><a href="SoundSetVolume.htm">SoundSetVolume</a> "+5"</code>.</td>
  </tr>
  <tr>
    <td>{Media_Next}</td>
    <td>Select next track in media player</td>
  </tr>
  <tr>
    <td>{Media_Prev}</td>
    <td>Select previous track in media player</td>
  </tr>
  <tr>
    <td>{Media_Stop}</td>
    <td>Stop media player</td>
  </tr>
  <tr>
    <td>{Media_Play_Pause}</td>
    <td>Play/pause media player</td>
  </tr>
  <tr>
    <td>{Launch_Mail}</td>
    <td>Launch the email application</td>
  </tr>
  <tr>
    <td>{Launch_Media}</td>
    <td>Launch media player</td>
  </tr>
  <tr>
    <td>{Launch_App1}</td>
    <td>Launch user app1</td>
  </tr>
  <tr>
    <td>{Launch_App2}</td>
    <td>Launch user app2</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{PrintScreen}</td>
    <td><kbd>PrintScreen</kbd></td>
  </tr>
  <tr>
    <td>{CtrlBreak}</td>
    <td><kbd>Ctrl</kbd>+<kbd>Pause</kbd></td>
  </tr>
  <tr>
    <td>{Pause}</td>
    <td><kbd>Pause</kbd></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr id="Click">
    <td>{Click [Options]}</td>
    <td>Sends a mouse click using the same options available in the <a href="Click.htm">Click function</a>. 例如, <code>Send "{Click}"</code> would click the left mouse button once at the mouse cursor's current position, and <code>Send "{Click 100, 200}"</code> would click at coordinates 100, 200 (based on <a href="CoordMode.htm">CoordMode</a>). To move the mouse without clicking, specify 0 after the coordinates; 例如: <code>Send "{Click 100, 200, 0}"</code>. The delay between mouse clicks is determined by <a href="SetMouseDelay.htm">SetMouseDelay</a> (not <a href="SetKeyDelay.htm">SetKeyDelay</a>).</td>
  </tr>
  <tr>
    <td>{WheelDown}, {WheelUp}, {WheelLeft}, {WheelRight}, {LButton}, {RButton}, {MButton}, {XButton1}, {XButton2}</td>
    <td>Sends a mouse button event at the cursor's current position (to have control over position and other options, use <a href="Click.htm">{Click}</a> above). The delay between mouse clicks is determined by <a href="SetMouseDelay.htm">SetMouseDelay</a>.</td>
  </tr>
  <tr>
    <td>{Blind}</td>
    <td>Enables the <a href="#blind">Blind mode</a>, which gives the script more control by disabling a number of things that are normally done automatically to make things generally work as expected. The string <code>{Blind}</code> must occur at the beginning of the string.</td>
  </tr>
  <tr>
    <td>{Raw}</td>
    <td>Enables the <a href="#SendRaw">Raw mode</a>, which causes the following characters to be interpreted literally: <code>^+!#{}</code>. Although the string <code>{Raw}</code> need not occur at the beginning of the string, once specified, it stays in effect for the remainder of the string.</td>
  </tr>
  <tr>
    <td>{Text}</td>
    <td>Enables the <a href="#SendText">Text mode</a>, which sends a stream of characters rather than keystrokes. Like the Raw mode, the Text mode causes the following characters to be interpreted literally: <code>^+!#{}</code>. Although the string <code>{Text}</code> need not occur at the beginning of the string, once specified, it stays in effect for the remainder of the string.</td>
  </tr>
</table>

<h2>重复或按住按键</h2>
<p id="repeat"><strong>重复键击</strong>: 用大括号括起按键名称和重复次数. 例如:</p>
<pre>Send "{DEL 4}"  <em>; 按 4 次 Delete 键.</em>
Send "{S 30}"   <em>; 发送 30 次大写字母 S.</em>
Send "+{TAB 4}"  <em>; 按 4 次 Shift-Tab.</em></pre>
<p id="Down"><strong>按住或释放按键</strong>: 用大括号括起按键名称和单词 <strong>Down</strong> 或 <strong>Up</strong>. 例如:</p>
<pre>Send "{b down}{b up}"
Send "{TAB down}{TAB up}"
Send "{Up down}"  <em>; 按下向上键.</em>
Sleep 1000  <em>; 按住 1 秒.</em>
Send "{Up up}"  <em>; 释放向上键.</em></pre>
<p>When a key is held down via the method above, it does not begin auto-repeating like it would if you were physically holding it down (this is because auto-repeat is a driver/hardware feature). However, a <a href="Loop.htm">Loop</a> can be used to simulate auto-repeat. The following example sends 20 tab keystrokes:</p>
<pre>Loop 20
{
    Send "{Tab down}"  <em>; Auto-repeat consists of consecutive down-events (with no up-events).</em>
    Sleep 30  <em>; The number of milliseconds between keystrokes (or use <a href="SetKeyDelay.htm">SetKeyDelay</a>).</em>
}
Send "{Tab up}"  <em>; Release the key.</em></pre>
<p>By default, Send will not automatically release a modifier key (<kbd>Control</kbd>/<kbd>Shift</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd>) if that modifier key was "pressed down" by sending it. For example, <code>Send "a"</code> may behave similar to <code>Send "<a href="#blind">{Blind}</a>{Ctrl up}a{Ctrl down}"</code> if the user is physically holding <kbd>Ctrl</kbd>, but <code>Send "{Ctrl Down}"</code> followed by <code>Send "a"</code> will produce a <kbd>Control</kbd>+<kbd>A</kbd> keystroke. <em>DownTemp</em> and <em>DownR</em> can be used to override this behavior. <em>DownTemp</em> and <em>DownR</em> have the same effect as <em>Down</em> except for the modifier keys (<kbd>Control</kbd>/<kbd>Shift</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd>).</p>
<p id="DownTemp"><strong>DownTemp</strong> tells subsequent sends that the key is not permanently down, and may be released whenever a keystroke calls for it. 例如, <code>Send "{Control DownTemp}"</code> followed later by <code>Send "a"</code> would produce a normal <kbd>A</kbd> keystroke, not a <kbd>Control</kbd>+<kbd>A</kbd> keystroke. Any use of Send may potentially release the modifier permanently, so <em>DownTemp</em> is not ideal for <a href="../misc/Remap.htm">remapping</a> modifier keys.</p>
<p id="DownR"><strong>DownR</strong> (where "R" stands for <a href="../misc/Remap.htm">remapping</a>, which is its main use) tells subsequent sends that if the key is automatically released, it should be pressed down again when send is finished. 例如, <code>Send "{Control DownR}"</code> followed later by <code>Send "a"</code> would produce a normal <kbd>A</kbd> keystroke, not a <kbd>Control</kbd>+<kbd>A</kbd> keystroke, but will leave the <kbd>Control</kbd> key in the pressed state for use with keyboard shortcuts. In other words, <em>DownR</em> has an effect similar to physically pressing the key.</p>
<p>If a character does not correspond to a virtual key on the current keyboard layout, it cannot be "pressed" or "released". 例如, <code>Send "{? up}"</code> has no effect on most layouts, and <code>Send "{? down}"</code> is equivalent to <code>Send "?"</code>.</p>

<h2 id="Remarks">备注</h2>
<p id="characters"><strong>字符 vs. 按键</strong>: 默认情况下, 先将字符转换为按键来发送字符. 如果这种转换是不可能的(即, 如果当前的键盘布局不包含产生该字符的键或键组合), 则通过以下回退方法之一来发送字符:</p>
<ul id="fallback">
  <li>SendEvent and SendInput use <a href="http://msdn.microsoft.com/en-us/library/ms646310">SendInput()</a> with the <a href="https://msdn.microsoft.com/en-us/library/ms646271#keyeventf_unicode">KEYEVENTF_UNICODE flag</a>.</li>
  <li>SendPlay uses the <a href="#asc">Alt+nnnnn</a> method, which produces Unicode only if supported by the target application.</li>
  <li>ControlSend posts a <a href="http://msdn.microsoft.com/en-us/library/ms646276.aspx">WM_CHAR</a> message.</li>
</ul>
<p class="warning"><strong>Note:</strong> Characters sent using any of the above methods usually do not trigger keyboard shortcuts or hotkeys.</p>
<p id="AZ">For characters in the range <strong>a-z</strong> or <strong>A-Z</strong> (plain ASCII letters), each character which does not exist in the current keyboard layout may be sent either as a character or as the corresponding virtual keycode (vk41-vk5A):</p>
<ul>
  <li>If a naked letter is sent (that is, without modifiers or braces), or if <a href="#Raw">Raw</a> mode is in effect, it is sent as a character. 例如, <code>Send "{Raw}Regards"</code> sends the expected text, even though pressing the <kbd>R</kbd> key (vk52) produces some other character (such as <kbd>??</kbd> on the Russian layout). <code>{Raw}</code> can be omitted in this case, unless a modifier key was put into effect by a prior Send.</li>
  <li>If one or more modifier keys have been put into effect by the Send function, or if the letter is wrapped in braces, it is sent as a keycode (modified with <kbd>Shift</kbd> if the letter is upper-case). This allows the script to easily activate standard keyboard shortcuts. 例如, <code>^c</code> and <code>{Ctrl down}c{Ctrl up}</code> activate the standard <kbd>Ctrl</kbd>+<kbd>C</kbd> shortcut and <code>{c}</code> is equivalent to <code>{vk43}</code>.</li>
</ul>
<p>If the letter exists in the current keyboard layout, it is always sent as whichever keycode the layout associates with that letter (unless the <a href="#SendText">Text mode</a> is used, in which case the character is sent by other means). In other words, the section above is only relevant for non-Latin based layouts such as Russian.</p>
<p id="mask"><strong>Modifier State</strong>: When Send is required to change the state of the <kbd>Win</kbd> or <kbd>Alt</kbd> modifier keys (such as if the user was holding one of those keys), it may inject additional keystrokes (<kbd>Ctrl</kbd> by default) to prevent the Start menu or window menu from appearing. For details, 请参阅 <a href="_MenuMaskKey.htm">#MenuMaskKey</a>.</p>
<p><strong>BlockInput Compared to SendInput/SendPlay</strong>: Although the <a href="BlockInput.htm">BlockInput</a> function can be used to prevent any keystrokes physically typed by the user from disrupting the flow of simulated keystrokes, it is often better to use <a href="#SendInputDetail">SendInput</a> or <a href="#SendPlayDetail">SendPlay</a> so that keystrokes and mouse clicks become uninterruptible. This is because unlike BlockInput, SendInput/Play does not discard what the user types during the send; instead, such keystrokes are buffered and sent afterward.</p>
<p>When sending a large number of keystrokes, a <a href="../Scripts.htm#continuation">continuation section</a> can be used to improve readability and maintainability.</p>
<p>Since the operating system does not allow simulation of the <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Delete</kbd> combination, doing something like <code>Send "^!{Delete}"</code> will have no effect.</p>
<p><b>Send may have no effect</b> if the active window is running with administrative privileges and the script is not. This is due to a security mechanism called User Interface Privilege Isolation.</p>

<h2 id="SendInputDetail">SendInput</h2>
<p>SendInput is generally the preferred method to send keystrokes and mouse clicks because of its superior speed and reliability. Under most conditions, SendInput is nearly instantaneous, even when sending long strings. Since SendInput is so fast, it is also more reliable because there is less opportunity for some other window to pop up unexpectedly and intercept the keystrokes. Reliability is further improved by the fact that anything the user types during a SendInput is postponed until afterward.</p>
<p>Unlike the other sending modes, the operating system limits SendInput to about 5000 characters (this may vary depending on the operating system's version and performance settings). Characters and events beyond this limit are not sent.</p>
<p class="note"><strong>Note:</strong> SendInput ignores SetKeyDelay because the operating system does not support a delay in this mode. However, when SendInput reverts to <a href="#SendEvent">SendEvent</a> under the conditions described below, it uses <code><a href="SetKeyDelay.htm">SetKeyDelay</a> -1, 0</code> (unless SendEvent's KeyDelay is <code>-1,-1</code>, in which case <code>-1,-1</code> is used). When SendInput reverts to <a href="#SendPlayDetail">SendPlay</a>, it uses SendPlay's KeyDelay.</p>
<p id="SendInputUnavail">If a script <em>other than</em> the one executing SendInput has a <a href="_InstallKeybdHook.htm">low-level keyboard hook</a> installed, SendInput automatically reverts to <a href="#SendEvent">SendEvent</a> (or <a href="#SendPlayDetail">SendPlay</a> if <code><a href="SendMode.htm">SendMode</a> "InputThenPlay"</code> is in effect). This is done because the presence of an external hook disables all of SendInput's advantages, making it inferior to both SendPlay and SendEvent. However, since SendInput is unable to detect a low-level hook in programs other than AutoHotkey v1.0.43+, it will not revert in these cases, making it less reliable than SendPlay/Event.</p>
<p>When SendInput sends mouse clicks by means such as <a href="#Click">{Click}</a>, and <code><a href="CoordMode.htm">CoordMode</a> "Mouse", "Relative"</code> is in effect (the default), every click will be relative to the window that was active at the start of the send. Therefore, if SendInput intentionally activates another window (by means such as alt-tab), the coordinates of subsequent clicks within the same function will be wrong because they will still be relative to the old window rather than the new one.</p>

<h2 id="SendPlayDetail">SendPlay</h2>
<p class="warning"><strong>Warning:</strong> SendPlay may have no effect at all if UAC is enabled, even if the script is running as an administrator. For more information, refer to the <a href="../FAQ.htm#uac">FAQ</a>.</p>
<p>SendPlay's biggest advantage is its ability to &quot;play back&quot; keystrokes and mouse clicks in a broader variety of games than the other modes. 例如, a particular game may accept <a href="../Hotstrings.htm#SendMode">hotstrings</a> only when they have the <a href="../Hotstrings.htm#SendMode">SendPlay option</a>.</p>
<p>Of the three sending modes, SendPlay is the most unusual because it does not simulate keystrokes and mouse clicks per se. Instead, it creates a series of events (messages) that flow directly to the active window (similar to <a href="ControlSend.htm">ControlSend</a>, but at a lower level). Consequently, SendPlay does not trigger hotkeys or hotstrings.</p>
<p>Like <a href="#SendInputDetail">SendInput</a>, SendPlay's keystrokes do not get interspersed with keystrokes typed by the user. Thus, if the user happens to type something during a SendPlay, those keystrokes are postponed until afterward.</p>
<p>Although SendPlay is considerably slower than SendInput, it is usually faster than the traditional <a href="#SendEvent">SendEvent</a> mode (even when <a href="SetKeyDelay.htm">KeyDelay</a> is -1).</p>
<p>The <kbd>Win</kbd> keys (LWin and RWin) are automatically blocked during a SendPlay if the <a href="_InstallKeybdHook.htm">keyboard hook</a> is installed. This prevents the Start Menu from appearing if the user accidentally presses a <kbd>Win</kbd> key during the send. By contrast, keys other than LWin and RWin do not need to be blocked because the operating system automatically postpones them until after the SendPlay (via buffering).</p>
<p>SendPlay does not use the standard settings of <a href="SetKeyDelay.htm">SetKeyDelay</a> and <a href="SetMouseDelay.htm">SetMouseDelay</a>. Instead, it defaults to no delay at all, which can be changed as shown in the following examples:</p>
<pre><a href="SetKeyDelay.htm">SetKeyDelay</a> 0, 10, <strong>"Play"</strong>  <em>; Note that both 0 and -1 are the same in SendPlay mode.</em>
<a href="SetMouseDelay.htm">SetMouseDelay</a> 10, <strong>"Play"</strong></pre>
<p>SendPlay is unable to turn on or off <kbd>CapsLock</kbd>, <kbd>NumLock</kbd>, or <kbd>ScrollLock</kbd>. Similarly, it is unable to change a key's state as seen by <a href="GetKeyState.htm">GetKeyState</a> unless the keystrokes are sent to one of the script's own windows. Even then, any changes to the left/right modifier keys (e.g. RControl) can be detected only via their neutral counterparts (e.g. Control). Also, SendPlay has other limitations described on the <a href="SendMode.htm#Play">SendMode page</a>.</p>
<p>Unlike <a href="#SendInputDetail">SendInput</a> and <a href="#SendEvent">SendEvent</a>, the user may interrupt a SendPlay by pressing <kbd>Control</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> or <kbd>Control</kbd>+<kbd>Escape</kbd>. When this happens, the remaining keystrokes are not sent but the script continues executing as though the SendPlay had completed normally.</p>
<p>Although SendPlay can send LWin and RWin events, they are sent directly to the active window rather than performing their native operating system function. To work around this, use <a href="#SendEvent">SendEvent</a>. 例如, <code>SendEvent "#r"</code> would show the Start Menu's Run dialog.</p>

<h2 id="Related">相关</h2>
<p><a href="SendMode.htm">SendMode</a>, <a href="SetKeyDelay.htm">SetKeyDelay</a>, <a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a>, <a href="../misc/EscapeChar.htm">转义序列(例 `n)</a>, <a href="ControlSend.htm">ControlSend</a>, <a href="BlockInput.htm">BlockInput</a>, <a href="../Hotstrings.htm">Hotstrings</a>, <a href="WinActivate.htm">WinActivate</a></p>

<h2 id="Examples">示例</h2>
<div class="ex" id="ExBasic">
<p><a href="#ExBasic">#1</a>: 基本使用</p>
<pre>Send "Sincerely,{enter}John Smith"  <em>; Types a two-line signature.</em>
Send "!fs" <em>; Select the File-&gt;Save menu (Alt+F followed by S).</em>
Send "{End}+{Left 4}" <em>; Jump to the end of the text then send four shift+left-arrow keystrokes.</em>
SendInput "<a href="#Raw">{Raw}</a>A long series of raw characters sent via the fastest method (<a href="#SendInputDetail">SendInput</a>)."</pre>
</div>

</body>
</html>