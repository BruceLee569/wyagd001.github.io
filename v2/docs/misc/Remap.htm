<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>重映射按键 (键盘, 鼠标和操纵杆) | AutoHotkey v2</title>
<meta name="description" content="Free keyboard remapper that can also remap mouse and joystick buttons. It can also automate repetitive tasks by sending keystrokes &amp; mouse clicks.">
<meta name="keywords" content="keyboard,remapper,remap,remapping,keys,key,keystrokes,clicks,mouse,buttons,button,joystick,hotkeys,hotkey">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>重映射按键 <span class="headnote">(键盘, 鼠标和操纵杆)</span></h1>

<h2 id="toc">目录</h2>
<ul>
  <li><a href="#intro">简介</a></li>
  <li><a href="#Remap">重映射键盘和鼠标</a></li>
  <li><a href="#remarks">备注</a></li>
  <li><a href="#moving-the-mouse-cursor">通过键盘移动鼠标光标</a></li>
  <li><a href="#registry">使用注册表的"扫描码映射"功能进行重映射</a></li>
  <li><a href="#related">相关话题</a></li>
</ul>

<h2 id="intro">简介</h2>
<p><strong>限制</strong>: 下面描述的 AutoHotkey 重映射功能通常不如直接通过 Windows 注册表进行映射那么纯粹和有效. 对于每种方法的优点和缺点, 请参阅<a href="#registry">注册表重映射.</a>.</p>
<h2 id="Remap">重映射键盘和鼠标</h2>
<p>内置重映射功能的语法为 <code>OriginKey::DestinationKey</code>. 例如, 只包含下面这行内容的<a href="../Scripts.htm">脚本</a>会将 <kbd>A</kbd> 键重映射成 <kbd>B</kbd> 键:</p>
<pre>a::b</pre>
<p>上面的例子并不改变 <kbd>B</kbd> 键本身. <kbd>B</kbd> 键将继续发送 &quot;b&quot; 的键击, 除非把它重映射到其他内容, 如下面的示例所示:</p>
<pre>a::b
b::a</pre>
<p>上述例子中使用小写字母, 在大多数情况下建议这么做, 因为它也会映射相应的大写字母(即在 <kbd>CapsLock</kbd> 打开或 <kbd>Shift</kbd> 键被按住时会发送大写形式). 与之相比, 在右边使用大写字母会强制发送大写形式. 例如, 下面的代码行在您输入 &quot;a&quot; 或 &quot;A&quot; 时都会产生大写字母 B(只要 <kbd>CapsLock</kbd> 是关闭的):</p>
<pre>a::B</pre>
<p>相反, 在发送按键时, 将自动释放包含在左侧但不包含在右侧的任何修饰符. 例如, 以下两行会产生一个小写字母 "b", 当你按下 Shift+A 或 Ctrl+A 时:</p>
<pre>A::b
^a::b</pre>

<h3 id="RemapMouse">鼠标重映射</h3>
<p>要重映射鼠标而不是键盘, 请使用相同的方法. 例如:</p>
<table class="info">
  <tr>
    <td><code>MButton::Shift</code></td>
    <td>把鼠标中键映射成 <kbd>Shift</kbd> 键.</td>
  </tr>
  <tr>
    <td><code>XButton1::LButton</code></td>
    <td>把第四个鼠标按钮映射成鼠标左键.</td>
  </tr>
  <tr>
    <td><code>RAlt::RButton</code></td>
    <td>把右 <kbd>Alt</kbd> 映射成鼠标右键.</td>
  </tr>
</table>

<h3 id="other-useful-remappings">其他有用的映射</h3>
<table class="info">
  <tr>
    <td><code>CapsLock::Ctrl</code></td>
    <td>把 <kbd>CapsLock</kbd> 映射成 <kbd>Ctrl</kbd> 键. 要保留打开及关闭 <kbd>CapsLock</kbd> 的功能, 需先包含重映射 <code>+CapsLock::CapsLock</code>. 这样, 当按住 <kbd>Shift</kbd> 并按下 <kbd>CapsLock</kbd> 时, 可切换 <kbd>CapsLock</kbd> 的开关状态. 因为两个重映射均允许附加修饰键被按下, 额外指定的 <code>+CapsLock::CapsLock</code> 重映射必须优先放置以便能正常工作.</td>
  </tr>
  <tr>
    <td><code>XButton2::^LButton</code></td>
    <td>把第五个鼠标按钮(XButton2) 映射成 control-click.</td>
  </tr>
  <tr>
    <td><code>RAlt::AppsKey</code></td>
    <td>把右 <kbd>Alt</kbd> 键映射成 <kbd>Menu</kbd> 键(这是打开上下文菜单的按键).</td>
  </tr>
  <tr>
    <td><code>RCtrl::RWin</code></td>
    <td>把右 <kbd>Ctrl</kbd> 键映射成右 <kbd>Win</kbd> 键.</td>
  </tr>
  <tr>
    <td><code>Ctrl::Alt</code></td>
    <td>把左右 <kbd>Ctrl</kbd> 键映射成 <kbd>Alt</kbd> 键. 但是, 请参阅 <a href="#AltTab">alt-tab 的问题</a>.</td>
  </tr>
  <tr>
    <td><code>^x::^c</code></td>
    <td>把 <kbd>Ctrl</kbd>+<kbd>X</kbd> 映射成 <kbd>Ctrl</kbd>+<kbd>C</kbd>. 它也会让 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>X</kbd> 映射成 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>C</kbd>, 等等.</td>
  </tr>
  <tr>
    <td><code>RWin::Return</code></td>
    <td>通过简单的<a href="../commands/Return.htm">return</a>, 来禁用右 <kbd>Win</kbd> 键.</td>
  </tr>
</table>
<p>您可以通过将这些示例复制到一个新的文本文件(如 "Remap") 中来尝试其中任何一个示例, 然后启动文件.</p>
<p>有关键和鼠标按钮名称的完整列表, 请参阅<a href="../KeyList.htm">按键列表</a>.</p>
<h2 id="remarks">备注</h2>
<p>The <a href="../commands/_If.htm">#If</a> directive can be used to make selected remappings active only in the windows you specify (or while any given condition is met). 例如:</p>
<pre>#If WinActive("ahk_class Notepad")
a::b  <em>; Makes the 'a' key send a 'b' key, but only in Notepad.</em>
#If  <em>; This puts subsequent remappings and hotkeys in effect for all windows.</em></pre>
<p>Remapping a key or button is &quot;complete&quot; in the following respects:</p>
<ul>
  <li>Holding down a modifier such as <kbd>Ctrl</kbd> or <kbd>Shift</kbd> while typing the origin key will put that modifier into effect for the destination key. 例如, <code>b::a</code> would produce <kbd>Ctrl</kbd>+<kbd>A</kbd> if you press <kbd>Ctrl</kbd>+<kbd>B</kbd>.</li>
  <li><kbd>CapsLock</kbd> generally affects remapped keys in the same way as normal keys.</li>
  <li>The destination key or button is held down for as long as you continue to hold down the origin key. However, some games do not support remapping; in such cases, the keyboard and mouse will behave as though not remapped.</li>
  <li>Remapped keys will auto-repeat while being held down (except keys remapped to become mouse buttons).</li>
</ul>
<p id="HookHotkeys">Although a remapped key can trigger normal hotkeys, by default it cannot trigger mouse hotkeys or <a href="../commands/_UseHook.htm">hook hotkeys</a> (use <a href="../commands/ListHotkeys.htm">ListHotkeys</a> to discover which hotkeys are &quot;hook&quot;). 例如, if the remapping <code>a::b</code> is in effect, pressing <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd> would trigger the <code>^!b</code> hotkey only if <code>^!b</code> is not a hook hotkey. If <code>^!b</code> is a hook hotkey, you can define <code>^!a</code> as a hotkey if you want <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd> to perform the same action as <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>B</kbd>. 例如:</p>
<pre>a::b
^!a::
^!b::
ToolTip "You pressed " A_ThisHotkey
return</pre>
<p>Alternatively, <a href="../commands/_InputLevel.htm">#InputLevel</a> can be used to override the default behaviour. 例如:</p>
<pre>#InputLevel 1
a::b

#InputLevel 0
^!b::
ToolTip "You pressed " A_ThisHotkey
return</pre>
<p id="SendPlay">If <a href="../commands/SendMode.htm">SendMode</a> is used in the auto-execute section (top part of the script), it affects all remappings. However, since remapping uses <a href="../commands/Send.htm#blind">Send "{Blind}"</a> and since the <a href="../commands/SendMode.htm">SendPlay mode</a> does not fully support  {Blind}, some remappings might not function properly in SendPlay mode (especially <kbd>Ctrl</kbd>, <kbd>Shift</kbd>, <kbd>Alt</kbd>, and <kbd>Win</kbd>). To work around this, avoid SendPlay in auto-execute section when you have remappings; then use the function <a href="../commands/Send.htm#SendPlay">SendPlay</a> vs. Send in other places throughout the script. Alternatively, you could translate your remappings into hotkeys (as described below) that explicitly call SendEvent vs. Send.</p>
<p id="actually">When a script is launched, each remapping is translated into a pair of <a href="../Hotkeys.htm">hotkeys</a>. 例如, a script containing <code>a::b</code> actually contains the following two hotkeys instead:</p>
<pre>*<strong>a</strong>::
SetKeyDelay -1   <em>; If the destination key is a mouse button, SetMouseDelay is used instead.</em>
Send "<a href="../commands/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownR}"  <em>; <a href="../commands/Send.htm#DownR">DownR</a> is like Down except that other Send functions in the script won't assume &quot;b&quot; should stay down during their Send.</em>
return

*<strong>a up</strong>::
SetKeyDelay -1  <em>; See note below for why press-duration is not specified with either of these SetKeyDelays.</em>
Send "{Blind}{<strong>b</strong> Up}"
return</pre>
<p>However, the above hotkeys vary under the following circumstances:</p>
<ol>
  <li>When the source key is the left <kbd>Ctrl</kbd> key and the destination key is an <kbd>Alt</kbd> key, the line <code>Send "{Blind}{LAlt DownR}"</code> is replaced by <code>Send "{Blind}<strong>{LCtrl up}</strong>{LAlt DownR}"</code>. The same is true if the source is the right <kbd>Ctrl</kbd> key, except that <code>{RCtrl up}</code> is used.</li>
  <li>When a keyboard key is being remapped to become a mouse button (e.g. <code>RCtrl::RButton</code>), the hotkeys above use SetMouseDelay in place of SetKeyDelay. In addition, the first hotkey above is replaced by the following, which prevents the keyboard's auto-repeat feature from generating repeated mouse clicks:
    <pre>*RCtrl::
SetMouseDelay -1
if not GetKeyState(&quot;RButton&quot;)  <em>; i.e. the right mouse button isn't down yet.</em>
    Send "{Blind}{RButton DownR}"
return</pre>
  </li>
  <li>When the source is a <a href="../Hotkeys.htm#combo">custom combination</a>, the wildcard modifier (*) is omitted to allow the hotkeys to work.</li>
</ol>
<p>Note that SetKeyDelay's second parameter (<a href="../commands/SetKeyDelay.htm#dur">press duration</a>) is omitted in the hotkeys above. This is because press-duration does not apply to down-only or up-only events such as <code>{b down}</code> and <code>{b up}</code>. However, it does apply to changes in the state of the <kbd>Shift</kbd>/<kbd>Ctrl</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd> keys, which affects remappings such as <code>a::B</code> or <code>a::^b</code>. Consequently, any press-duration a script puts into effect via its <a href="../Scripts.htm#auto">auto-execute section</a> will apply to all such remappings.</p>
<p>Since remappings are translated into hotkeys as described above, the <a href="../commands/Suspend.htm">Suspend</a> function affects them. Similarly, the <a href="../commands/Hotkey.htm">Hotkey</a> function can disable or modify a remapping. 例如, the following two functions would disable the remapping <code>a::b</code>.</p>
<pre>Hotkey "*a", "Off"
Hotkey "*a up", "Off"</pre>
<p id="AltTab">Alt-tab issues: If you remap a key or mouse button to become an <kbd>Alt</kbd> key, that key will probably not be able to alt-tab properly. A possible work-around is to add the hotkey <code>*Tab::Send "{Blind}{Tab}"</code> -- but be aware that it will likely interfere with using the real <kbd>Alt</kbd> key to alt-tab. Therefore, it should be used only when you alt-tab solely by means of remapped keys and/or <a href="../Hotkeys.htm#alttab">alt-tab hotkeys</a>.</p>
<p>In addition to the keys and mouse buttons on the <a href="../KeyList.htm">Key List</a> page, the source key may also be a virtual key (VKnn) or scan code (SCnnn) as described on the <a href="../KeyList.htm#SpecialKeys">special keys</a> page. The same is true for the destination key except that it may optionally specify a scan code after the virtual key. 例如, <code>sc01e::vk42sc030</code> is equivalent to <code>a::b</code> on most keyboard layouts.</p>
<p>To disable a key rather than remapping it, make it a hotkey that simply <a href="../commands/Return.htm">returns</a>. 例如, <code>F1::return</code> would disable the <kbd>F1</kbd> key.</p>
<p>The following keys are not supported by the built-in remapping method:</p>
<ul>
  <li>The mouse wheel (WheelUp/Down/Left/Right).</li>
  <li>Pause and Break as destination keys (since they match the names of built-in functions).</li>
  <li>Curly braces {} as destination keys. Instead use the <a href="../commands/Send.htm#vk">VK/SC method</a>; e.g. <code>x::+sc01A</code> and <code>y::+sc01B</code>.</li>
  <li>&quot;Return&quot; as a destination key. Instead use &quot;Enter&quot;.</li>
</ul>
<h2 id="moving-the-mouse-cursor">通过键盘移动鼠标光标</h2>
<p>The keyboard can be used to move the mouse cursor as demonstrated by the fully-featured <a href="../scripts/NumpadMouse.htm">Keyboard-To-Mouse script</a>. Since that script offers smooth cursor movement, acceleration, and other features, it is the recommended approach if you plan to do a lot of mousing with the keyboard. By contrast, the following example is a simpler demonstration:</p>
<pre>*#up::MouseMove 0, -10, 0, "R"  <em>; Win+UpArrow hotkey =&gt; Move cursor upward</em>
*#Down::MouseMove 0, 10, 0, "R"  <em>; Win+DownArrow =&gt; Move cursor downward</em>
*#Left::MouseMove -10, 0, 0, "R"  <em>; Win+LeftArrow =&gt; Move cursor to the left</em>
*#Right::MouseMove 10, 0, 0, "R"  <em>; Win+RightArrow =&gt; Move cursor to the right</em>

*&lt;#RCtrl::  <em>; LeftWin + RightControl =&gt; Left-click (hold down Control/Shift to Control-Click or Shift-Click).</em>
SendEvent "{Blind}{LButton down}"
KeyWait "RCtrl"  <em>; Prevents keyboard auto-repeat from repeating the mouse click.</em>
SendEvent "{Blind}{LButton up}"
return

*&lt;#AppsKey::  <em>; LeftWin + AppsKey =&gt; Right-click</em>
SendEvent "{Blind}{RButton down}"
KeyWait "AppsKey"  <em>; Prevents keyboard auto-repeat from repeating the mouse click.</em>
SendEvent "{Blind}{RButton up}"
return</pre>
<h2 id="registry">使用注册表的"扫描码映射"功能进行重映射</h2>
<p><strong>优点:</strong></p>
<ul>
  <li>Registry remapping is generally more pure and effective than <a href="#Remap">AutoHotkey's remapping</a>. 例如, it works in a broader variety of games, it has no known <a href="#AltTab">alt-tab issues</a>, and it is capable of firing AutoHotkey's hook hotkeys  (whereas AutoHotkey's remapping requires a <a href="#HookHotkeys">workaround</a>).</li>
  <li>If you choose to make the registry entries manually (explained below), absolutely no external software is needed to remap your keyboard. Even if you use <a href="https://www.bleepingcomputer.com/download/keytweak/">KeyTweak</a> to make the registry entries for you, KeyTweak does not need to stay running all the time (unlike AutoHotkey).</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
  <li>Registry remapping is relatively permanent: a reboot is required to undo the changes or put new ones into effect.</li>
  <li>Its effect is global: it cannot create remappings specific to a particular user, application, or locale.</li>
  <li>It cannot send keystrokes that are modified by <kbd>Shift</kbd>, <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, or <kbd>AltGr</kbd>. 例如, it cannot remap a lowercase character to an uppercase one.</li>
  <li>It supports only the keyboard (AutoHotkey has <a href="#RemapMouse">mouse remapping</a> and some <a href="RemapJoystick.htm">limited joystick remapping</a>).</li>
</ul>
<p><strong>How to Apply Changes to the Registry:</strong> There are at least two methods to remap keys via the registry:</p>
<ol>
  <li>Use a program like <a href="https://www.bleepingcomputer.com/download/keytweak/">KeyTweak</a> (freeware) to visually remap your keys. It will change the registry for you.</li>
  <li>Remap keys manually by creating a .reg file (plain text) and loading it into the registry. This is demonstrated at <a href="http://www.autohotkey.com/forum/post-56216.html#56216">www.autohotkey.com/forum/post-56216.html#56216</a></li>
</ol>
<h2 id="related">相关话题</h2>
<p><a href="../KeyList.htm#Joystick">按键和鼠标按钮列表</a><br>
<a href="../commands/GetKeyState.htm">GetKeyState</a><br>
<a href="RemapJoystick.htm">重映射操纵杆</a></p>
</body>
</html>